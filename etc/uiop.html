<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- UIOP is a part of https://common-lisp.net/project/asdf/ (ASDF),
which is released under an MIT style License:

Copyright (C) 2001-2018 Daniel Barlow and contributors.
  
Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the "Software"), to deal in
  the Software without restriction, including without limitation the rights to
  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  the Software, and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:
  
The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
  
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. -->
<!-- Created by GNU Texinfo 6.3, http://www.gnu.org/software/texinfo/ -->
<head>
<title>UIOP Manual</title>

<meta name="description" content="UIOP Manual">
<meta name="keywords" content="UIOP Manual">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="#Top" rel="start" title="Top">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">UIOP Manual</h1>




<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-Introduction-1" href="#Introduction">1 Introduction</a></li>
  <li><a name="toc-UIOP_002fPACKAGE-1" href="#UIOP_002fPACKAGE">2 UIOP/PACKAGE</a></li>
  <li><a name="toc-UIOP_002fCOMMON_002dLISP-1" href="#UIOP_002fCOMMON_002dLISP">3 UIOP/COMMON-LISP</a></li>
  <li><a name="toc-UIOP_002fUTILITY-1" href="#UIOP_002fUTILITY">4 UIOP/UTILITY</a></li>
  <li><a name="toc-UIOP_002fVERSION-1" href="#UIOP_002fVERSION">5 UIOP/VERSION</a></li>
  <li><a name="toc-UIOP_002fOS-1" href="#UIOP_002fOS">6 UIOP/OS</a></li>
  <li><a name="toc-UIOP_002fPATHNAME-1" href="#UIOP_002fPATHNAME">7 UIOP/PATHNAME</a></li>
  <li><a name="toc-UIOP_002fFILESYSTEM-1" href="#UIOP_002fFILESYSTEM">8 UIOP/FILESYSTEM</a></li>
  <li><a name="toc-UIOP_002fSTREAM-1" href="#UIOP_002fSTREAM">9 UIOP/STREAM</a></li>
  <li><a name="toc-UIOP_002fIMAGE-1" href="#UIOP_002fIMAGE">10 UIOP/IMAGE</a></li>
  <li><a name="toc-UIOP_002fLISP_002dBUILD-1" href="#UIOP_002fLISP_002dBUILD">11 UIOP/LISP-BUILD</a></li>
  <li><a name="toc-UIOP_002fLAUNCH_002dPROGRAM-1" href="#UIOP_002fLAUNCH_002dPROGRAM">12 UIOP/LAUNCH-PROGRAM</a></li>
  <li><a name="toc-UIOP_002fRUN_002dPROGRAM-1" href="#UIOP_002fRUN_002dPROGRAM">13 UIOP/RUN-PROGRAM</a></li>
  <li><a name="toc-UIOP_002fCONFIGURATION-1" href="#UIOP_002fCONFIGURATION">14 UIOP/CONFIGURATION</a></li>
  <li><a name="toc-UIOP_002fBACKWARD_002dDRIVER-1" href="#UIOP_002fBACKWARD_002dDRIVER">15 UIOP/BACKWARD-DRIVER</a></li>
  <li><a name="toc-UIOP_002fDRIVER-1" href="#UIOP_002fDRIVER">16 UIOP/DRIVER</a></li>
</ul>
</div>




<a name="Top"></a>
<div class="header">
<p>
Next: <a href="#Introduction" accesskey="n" rel="next">Introduction</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP"></a>
<h1 class="top">UIOP</h1>

<p>UIOP is a part of <a href="https://common-lisp.net/project/asdf/">ASDF</a>,
which is released under an MIT style License:
</p>
<blockquote>
<p>Copyright &copy; 2001-2018 Daniel Barlow and contributors.
</p>  
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the &quot;Software&quot;), to deal in
  the Software without restriction, including without limitation the rights to
  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  the Software, and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:
</p>  
<p>The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
</p>  
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p></blockquote>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Introduction" accesskey="1">Introduction</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fPACKAGE" accesskey="2">UIOP/PACKAGE</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fCOMMON_002dLISP" accesskey="3">UIOP/COMMON-LISP</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fUTILITY" accesskey="4">UIOP/UTILITY</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fVERSION" accesskey="5">UIOP/VERSION</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fOS" accesskey="6">UIOP/OS</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fPATHNAME" accesskey="7">UIOP/PATHNAME</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fFILESYSTEM" accesskey="8">UIOP/FILESYSTEM</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fSTREAM" accesskey="9">UIOP/STREAM</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fIMAGE">UIOP/IMAGE</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fLISP_002dBUILD">UIOP/LISP-BUILD</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fLAUNCH_002dPROGRAM">UIOP/LAUNCH-PROGRAM</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fRUN_002dPROGRAM">UIOP/RUN-PROGRAM</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fCONFIGURATION">UIOP/CONFIGURATION</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fBACKWARD_002dDRIVER">UIOP/BACKWARD-DRIVER</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UIOP_002fDRIVER">UIOP/DRIVER</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr></table>


<hr>
<a name="Introduction"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fPACKAGE" accesskey="n" rel="next">UIOP/PACKAGE</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Introduction-1"></a>
<h2 class="chapter">1 Introduction</h2>

<p>UIOP is the portability layer of ASDF. It provides utilities that
abstract over discrepancies between implementations, between operating
systems, and between what the standard provides and what programmers
actually need, to write portable Common Lisp programs.
</p>
<p>It is organized by topic in many packages, all of which are available
in a single package <code>uiop</code>.
</p>
<p>The following API reference is auto-generated from the docstrings in
the code. The chapters are arranged in dependency order.
</p>
<hr>
<a name="UIOP_002fPACKAGE"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fCOMMON_002dLISP" accesskey="n" rel="next">UIOP/COMMON-LISP</a>, Previous: <a href="#Introduction" accesskey="p" rel="prev">Introduction</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fPACKAGE-1"></a>
<h2 class="chapter">2 UIOP/PACKAGE</h2>

<a name="Function-uiop_002fpackage_003afind_002dsymbol_002a"></a><dl>
<dt><a name="index-find_002dsymbol_002a"></a>Function: <strong>find-symbol*</strong> <em>name package-designator &amp;optional  error</em></dt>
<dd><a name="index-uiop_002fpackage_003afind_002dsymbol_002a"></a>
<p>Find a symbol in a package of given string&rsquo;ified <code>name</code>;
unlike <code>cl:find-symbol</code>, work well with &rsquo;modern&rsquo; case sensitive syntax
by letting you supply a symbol or keyword for the name;
also works well when the package is not present.
If optional <code>error</code> argument is <code>nil</code>, return <code>nil</code> instead of an error
when the symbol is not found.
</p></dd></dl>
<a name="Function-uiop_002fpackage_003arehome_002dsymbol"></a><dl>
<dt><a name="index-rehome_002dsymbol"></a>Function: <strong>rehome-symbol</strong> <em>symbol package-designator</em></dt>
<dd><a name="index-uiop_002fpackage_003arehome_002dsymbol"></a>
<p>Changes the home package of a symbol, also leaving it present in its old home if any
</p></dd></dl>
<a name="Function-uiop_002fpackage_003asymbol_002dcall"></a><dl>
<dt><a name="index-symbol_002dcall"></a>Function: <strong>symbol-call</strong> <em>package name &amp;rest  args</em></dt>
<dd><a name="index-uiop_002fpackage_003asymbol_002dcall"></a>
<p>Call a function associated with symbol of given name in given package,
with given <code>args</code>. Useful when the call is read before the package is loaded,
or when loading the package is optional.
</p></dd></dl>
<a name="Macro-uiop_002fpackage_003adefine_002dpackage"></a><dl>
<dt><a name="index-define_002dpackage"></a>Macro: <strong>define-package</strong> <em>package &amp;rest  clauses</em></dt>
<dd><a name="index-uiop_002fpackage_003adefine_002dpackage"></a>
<p><code>define-package</code> takes a <code>package</code> and a number of <code>clauses</code>, of the form
(<code>keyword</code> . <code>args</code>).
<code>define-package</code> supports the following keywords:
<code>use</code>, <code>shadow</code>, <code>shadowing-import-from</code>, <code>import-from</code>, <code>export</code>, <code>intern</code> <code>--</code> as per <code>cl:defpackage</code>.
<code>recycle</code> <code>--</code> Recycle the package&rsquo;s exported symbols from the specified packages,
in order.  For every symbol scheduled to be exported by the <code>define-package</code>,
either through an <code>:export</code> option or a <code>:reexport</code> option, if the symbol exists in
one of the <code>:recycle</code> packages, the first such symbol is re-homed to the package
being defined.
For the sake of idempotence, it is important that the package being defined
should appear in first position if it already exists, and even if it doesn&rsquo;t,
ahead of any package that is not going to be deleted afterwards and never
created again. In short, except for special cases, always make it the first
package on the list if the list is not empty.
<code>mix</code> <code>--</code> Takes a list of package designators.  <code>mix</code> behaves like
(<code>:use</code> <code>pkg1</code> <code>pkg2</code> ... PKGn) but additionally uses <code>:shadowing-import-from</code> to
resolve conflicts in favor of the first found symbol.  It may still yield
an error if there is a conflict with an explicitly <code>:import-from</code> symbol.
<code>reexport</code> <code>--</code> Takes a list of package designators.  For each package, p, in the list,
export symbols with the same name as those exported from p.  Note that in the case
of shadowing, etc. the symbols with the same name may not be the same symbols.
<code>unintern</code> <code>--</code> Remove symbols here from <code>package</code>.
</p></dd></dl>

<hr>
<a name="UIOP_002fCOMMON_002dLISP"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fUTILITY" accesskey="n" rel="next">UIOP/UTILITY</a>, Previous: <a href="#UIOP_002fPACKAGE" accesskey="p" rel="prev">UIOP/PACKAGE</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fCOMMON_002dLISP-1"></a>
<h2 class="chapter">3 UIOP/COMMON-LISP</h2>

<p><code>uiop/common-lisp</code> lets you paper over various sub-standard
implementations.
</p>
<p>This package reexports all the symbols in <code>common-lisp</code> package.
</p>
<hr>
<a name="UIOP_002fUTILITY"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fVERSION" accesskey="n" rel="next">UIOP/VERSION</a>, Previous: <a href="#UIOP_002fCOMMON_002dLISP" accesskey="p" rel="prev">UIOP/COMMON-LISP</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fUTILITY-1"></a>
<h2 class="chapter">4 UIOP/UTILITY</h2>

<a name="Function-uiop_002futility_003aaccess_002dat_002dcount"></a><dl>
<dt><a name="index-access_002dat_002dcount"></a>Function: <strong>access-at-count</strong> <em>at</em></dt>
<dd><a name="index-uiop_002futility_003aaccess_002dat_002dcount"></a>
<p>From an <code>at</code> specification, extract a <code>count</code> of maximum number
of sub-objects to read as per <code>access-at</code>
</p></dd></dl>
<a name="Function-uiop_002futility_003aaccess_002dat"></a><dl>
<dt><a name="index-access_002dat"></a>Function: <strong>access-at</strong> <em>object at</em></dt>
<dd><a name="index-uiop_002futility_003aaccess_002dat"></a>
<p>Given an <code>object</code> and an <code>at</code> specifier, list of successive accessors,
call each accessor on the result of the previous calls.
An accessor may be an integer, meaning a call to <code>elt</code>,
a keyword, meaning a call to <code>getf</code>,
<code>nil</code>, meaning identity,
a function or other symbol, meaning itself,
or a list of a function designator and arguments, interpreted as per <code>ensure-function</code>.
As a degenerate case, the <code>at</code> specifier may be an atom of a single such accessor
instead of a list.
</p></dd></dl>
<a name="Function-uiop_002futility_003abase_002dstring_002dp"></a><dl>
<dt><a name="index-base_002dstring_002dp"></a>Function: <strong>base-string-p</strong> <em>string</em></dt>
<dd><a name="index-uiop_002futility_003abase_002dstring_002dp"></a>
<p>Does the <code>string</code> only contain BASE-CHARs?
</p></dd></dl>
<a name="Function-uiop_002futility_003acall_002dfunction"></a><dl>
<dt><a name="index-call_002dfunction"></a>Function: <strong>call-function</strong> <em>function-spec &amp;rest  arguments</em></dt>
<dd><a name="index-uiop_002futility_003acall_002dfunction"></a>
<p>Call the function designated by <code>function-spec</code> as per <code>ensure-function</code>,
with the given <code>arguments</code>
</p></dd></dl>
<a name="Function-uiop_002futility_003acall_002dfunctions"></a><dl>
<dt><a name="index-call_002dfunctions"></a>Function: <strong>call-functions</strong> <em>function-specs</em></dt>
<dd><a name="index-uiop_002futility_003acall_002dfunctions"></a>
<p>For each function in the list <code>function-specs</code>, in order, call the function as per <code>call-function</code>
</p></dd></dl>
<a name="Function-uiop_002futility_003acall_002dwith_002dmuffled_002dconditions"></a><dl>
<dt><a name="index-call_002dwith_002dmuffled_002dconditions"></a>Function: <strong>call-with-muffled-conditions</strong> <em>thunk conditions</em></dt>
<dd><a name="index-uiop_002futility_003acall_002dwith_002dmuffled_002dconditions"></a>
<p>calls the <code>thunk</code> in a context where the <code>conditions</code> are muffled
</p></dd></dl>
<a name="Function-uiop_002futility_003acoerce_002dclass"></a><dl>
<dt><a name="index-coerce_002dclass"></a>Function: <strong>coerce-class</strong> <em>class &amp;key  package super error</em></dt>
<dd><a name="index-uiop_002futility_003acoerce_002dclass"></a>
<p>Coerce <code>class</code> to a class that is subclass of <code>super</code> if specified,
or invoke <code>error</code> handler as per <code>call-function</code>.
</p>
<p>A keyword designates the name a symbol, which when found in either <code>package</code>, designates a class.
<code>--</code> for backward compatibility, <code>*package*</code> is also accepted for now, but this may go in the future.
A string is read as a symbol while in <code>package</code>, the symbol designates a class.
</p>
<p>A class object designates itself.
<code>nil</code> designates itself (no class).
A symbol otherwise designates a class by name.
</p></dd></dl>
<a name="Function-uiop_002futility_003aemptyp"></a><dl>
<dt><a name="index-emptyp"></a>Function: <strong>emptyp</strong> <em>x</em></dt>
<dd><a name="index-uiop_002futility_003aemptyp"></a>
<p>Predicate that is true for an empty sequence
</p></dd></dl>
<a name="Function-uiop_002futility_003aensure_002dfunction"></a><dl>
<dt><a name="index-ensure_002dfunction"></a>Function: <strong>ensure-function</strong> <em>fun &amp;key  package</em></dt>
<dd><a name="index-uiop_002futility_003aensure_002dfunction"></a>
<p>Coerce the object <code>fun</code> into a function.
</p>
<p>If <code>fun</code> is a <code>function</code>, return it.
If the <code>fun</code> is a non-sequence literal constant, return constantly that,
i.e. for a boolean keyword character number or pathname.
Otherwise if <code>fun</code> is a non-literally constant symbol, return its <code>fdefinition</code>.
If <code>fun</code> is a <code>cons</code>, return the function that applies its <code>car</code>
to the appended list of the rest of its <code>cdr</code> and the arguments,
unless the <code>car</code> is <code>lambda</code>, in which case the expression is evaluated.
If <code>fun</code> is a string, <code>read</code> a form from it in the specified <code>package</code> (default: CL)
and <code>eval</code> that in a (<code>function</code> ...) context.
</p></dd></dl>
<a name="Function-uiop_002futility_003aensure_002dgethash"></a><dl>
<dt><a name="index-ensure_002dgethash"></a>Function: <strong>ensure-gethash</strong> <em>key table default</em></dt>
<dd><a name="index-uiop_002futility_003aensure_002dgethash"></a>
<p>Lookup the <code>table</code> for a <code>key</code> as by <code>gethash</code>, but if not present,
call the (possibly constant) function designated by <code>default</code> as per <code>call-function</code>,
set the corresponding entry to the result in the table.
Return two values: the entry after its optional computation, and whether it was found
</p></dd></dl>
<a name="Function-uiop_002futility_003afind_002dstandard_002dcase_002dsymbol"></a><dl>
<dt><a name="index-find_002dstandard_002dcase_002dsymbol"></a>Function: <strong>find-standard-case-symbol</strong> <em>name-designator package-designator &amp;optional  error</em></dt>
<dd><a name="index-uiop_002futility_003afind_002dstandard_002dcase_002dsymbol"></a>
<p>Find a symbol designated by <code>name-designator</code> in a package designated by <code>package-designator</code>,
where <code>standard-case-symbol-name</code> is used to transform them if these designators are strings.
If optional <code>error</code> argument is <code>nil</code>, return <code>nil</code> instead of an error when the symbol is not found.
</p></dd></dl>
<a name="Function-uiop_002futility_003afirst_002dchar"></a><dl>
<dt><a name="index-first_002dchar"></a>Function: <strong>first-char</strong> <em>s</em></dt>
<dd><a name="index-uiop_002futility_003afirst_002dchar"></a>
<p>Return the first character of a non-empty string <code>s</code>, or <code>nil</code>
</p></dd></dl>
<a name="Function-uiop_002futility_003afrob_002dsubstrings"></a><dl>
<dt><a name="index-frob_002dsubstrings"></a>Function: <strong>frob-substrings</strong> <em>string substrings &amp;optional  frob</em></dt>
<dd><a name="index-uiop_002futility_003afrob_002dsubstrings"></a>
<p>for each substring in <code>substrings</code>, find occurrences of it within <code>string</code>
that don&rsquo;t use parts of matched occurrences of previous strings, and
<code>frob</code> them, that is to say, remove them if <code>frob</code> is <code>nil</code>,
replace by <code>frob</code> if <code>frob</code> is a <code>string</code>, or if <code>frob</code> is a <code>function</code>,
call <code>frob</code> with the match and a function that emits a string in the output.
Return a string made of the parts not omitted or emitted by <code>frob</code>.
</p></dd></dl>
<a name="Function-uiop_002futility_003alast_002dchar"></a><dl>
<dt><a name="index-last_002dchar"></a>Function: <strong>last-char</strong> <em>s</em></dt>
<dd><a name="index-uiop_002futility_003alast_002dchar"></a>
<p>Return the last character of a non-empty string <code>s</code>, or <code>nil</code>
</p></dd></dl>
<a name="Function-uiop_002futility_003alexicographic_003c_003d"></a><dl>
<dt><a name="index-lexicographic_003c_003d"></a>Function: <strong>lexicographic&lt;=</strong> <em>element&lt; x y</em></dt>
<dd><a name="index-uiop_002futility_003alexicographic_003c_003d"></a>
<p>Lexicographically compare two lists of using the function element&lt; to compare elements.
element&lt; is a strict total order; the resulting order on <code>x</code> and <code>y</code> will be a non-strict total order.
</p></dd></dl>
<a name="Function-uiop_002futility_003alexicographic_003c"></a><dl>
<dt><a name="index-lexicographic_003c"></a>Function: <strong>lexicographic&lt;</strong> <em>element&lt; x y</em></dt>
<dd><a name="index-uiop_002futility_003alexicographic_003c"></a>
<p>Lexicographically compare two lists of using the function element&lt; to compare elements.
element&lt; is a strict total order; the resulting order on <code>x</code> and <code>y</code> will also be strict.
</p></dd></dl>
<a name="Function-uiop_002futility_003alist_002dto_002dhash_002dset"></a><dl>
<dt><a name="index-list_002dto_002dhash_002dset"></a>Function: <strong>list-to-hash-set</strong> <em>list &amp;aux (h (make-hash-table test (quote equal)))</em></dt>
<dd><a name="index-uiop_002futility_003alist_002dto_002dhash_002dset"></a>
<p>Convert a <code>list</code> into hash-table that has the same elements when viewed as a set,
up to the given equality <code>test</code>
</p></dd></dl>
<a name="Function-uiop_002futility_003amatch_002dany_002dcondition_002dp"></a><dl>
<dt><a name="index-match_002dany_002dcondition_002dp"></a>Function: <strong>match-any-condition-p</strong> <em>condition conditions</em></dt>
<dd><a name="index-uiop_002futility_003amatch_002dany_002dcondition_002dp"></a>
<p>match <code>condition</code> against any of the patterns of <code>conditions</code> supplied
</p></dd></dl>
<a name="Function-uiop_002futility_003amatch_002dcondition_002dp"></a><dl>
<dt><a name="index-match_002dcondition_002dp"></a>Function: <strong>match-condition-p</strong> <em>x condition</em></dt>
<dd><a name="index-uiop_002futility_003amatch_002dcondition_002dp"></a>
<p>Compare received <code>condition</code> to some pattern <code>x:</code>
a symbol naming a condition class,
a simple vector of length <code>2</code>, arguments to find-symbol* with result as above,
or a string describing the format-control of a simple-condition.
</p></dd></dl>
<a name="Function-uiop_002futility_003anot_002dimplemented_002derror"></a><dl>
<dt><a name="index-not_002dimplemented_002derror"></a>Function: <strong>not-implemented-error</strong> <em>functionality &amp;optional  format-control &amp;rest  format-arguments</em></dt>
<dd><a name="index-uiop_002futility_003anot_002dimplemented_002derror"></a>
<p>Signal an error because some <code>functionality</code> is not implemented in the current version
of the software on the current platform; it may or may not be implemented in different combinations
of version of the software and of the underlying platform. Optionally, report a formatted error
message.
</p></dd></dl>
<a name="Function-uiop_002futility_003aparameter_002derror"></a><dl>
<dt><a name="index-parameter_002derror"></a>Function: <strong>parameter-error</strong> <em>format-control functionality &amp;rest  format-arguments</em></dt>
<dd><a name="index-uiop_002futility_003aparameter_002derror"></a>
<p>Signal an error because some <code>functionality</code> or its specific implementation on a given underlying
platform does not accept a given parameter or combination of parameters. Report a formatted error
message, that takes the functionality as its first argument (that can be skipped with ~*).
</p></dd></dl>
<a name="Function-uiop_002futility_003aparse_002dbody"></a><dl>
<dt><a name="index-parse_002dbody"></a>Function: <strong>parse-body</strong> <em>body &amp;key  documentation whole</em></dt>
<dd><a name="index-uiop_002futility_003aparse_002dbody"></a>
<p>Parses <code>body</code> into (values remaining-forms declarations doc-string).
Documentation strings are recognized only if <code>documentation</code> is true.
Syntax errors in body are signalled and <code>whole</code> is used in the signal
arguments when given.
</p></dd></dl>
<a name="Function-uiop_002futility_003areduce_002fstrcat"></a><dl>
<dt><a name="index-reduce_002fstrcat"></a>Function: <strong>reduce/strcat</strong> <em>strings &amp;key  key start end</em></dt>
<dd><a name="index-uiop_002futility_003areduce_002fstrcat"></a>
<p>Reduce a list as if by <code>strcat</code>, accepting <code>key</code> <code>start</code> and <code>end</code> keywords like <code>reduce</code>.
<code>nil</code> is interpreted as an empty string. A character is interpreted as a string of length one.
</p></dd></dl>
<a name="Function-uiop_002futility_003aregister_002dhook_002dfunction"></a><dl>
<dt><a name="index-register_002dhook_002dfunction"></a>Function: <strong>register-hook-function</strong> <em>variable hook &amp;optional  call-now-p</em></dt>
<dd><a name="index-uiop_002futility_003aregister_002dhook_002dfunction"></a>
<p>Push the <code>hook</code> function (a designator as per <code>ensure-function</code>) onto the hook <code>variable</code>.
When <code>call-now-p</code> is true, also call the function immediately.
</p></dd></dl>
<a name="Function-uiop_002futility_003aremove_002dplist_002dkey"></a><dl>
<dt><a name="index-remove_002dplist_002dkey"></a>Function: <strong>remove-plist-key</strong> <em>key plist</em></dt>
<dd><a name="index-uiop_002futility_003aremove_002dplist_002dkey"></a>
<p>Remove a single key from a plist
</p></dd></dl>
<a name="Function-uiop_002futility_003aremove_002dplist_002dkeys"></a><dl>
<dt><a name="index-remove_002dplist_002dkeys"></a>Function: <strong>remove-plist-keys</strong> <em>keys plist</em></dt>
<dd><a name="index-uiop_002futility_003aremove_002dplist_002dkeys"></a>
<p>Remove a list of keys from a plist
</p></dd></dl>
<a name="Function-uiop_002futility_003asplit_002dstring"></a><dl>
<dt><a name="index-split_002dstring"></a>Function: <strong>split-string</strong> <em>string &amp;key  max separator</em></dt>
<dd><a name="index-uiop_002futility_003asplit_002dstring"></a>
<p>Split <code>string</code> into a list of components separated by
any of the characters in the sequence <code>separator</code>.
If <code>max</code> is specified, then no more than max(<code>1</code>,<code>max</code>) components will be returned,
starting the separation from the end, e.g. when called with arguments
 &quot;a.b.c.d.e&quot; :max <code>3</code> :separator &quot;.&quot; it will return (&quot;a.b.c&quot; &quot;d&quot; &quot;e&quot;).
</p></dd></dl>
<a name="Function-uiop_002futility_003astandard_002dcase_002dsymbol_002dname"></a><dl>
<dt><a name="index-standard_002dcase_002dsymbol_002dname"></a>Function: <strong>standard-case-symbol-name</strong> <em>name-designator</em></dt>
<dd><a name="index-uiop_002futility_003astandard_002dcase_002dsymbol_002dname"></a>
<p>Given a <code>name-designator</code> for a symbol, if it is a symbol, convert it to a string using <code>string</code>;
if it is a string, use <code>string-upcase</code> on an ANSI CL platform, or <code>string</code> on a so-called &quot;modern&quot;
platform such as Allegro with modern syntax.
</p></dd></dl>
<a name="Function-uiop_002futility_003astrcat"></a><dl>
<dt><a name="index-strcat"></a>Function: <strong>strcat</strong> <em>&amp;rest  strings</em></dt>
<dd><a name="index-uiop_002futility_003astrcat"></a>
<p>Concatenate strings.
<code>nil</code> is interpreted as an empty string, a character as a string of length one.
</p></dd></dl>
<a name="Function-uiop_002futility_003astring_002denclosed_002dp"></a><dl>
<dt><a name="index-string_002denclosed_002dp"></a>Function: <strong>string-enclosed-p</strong> <em>prefix string suffix</em></dt>
<dd><a name="index-uiop_002futility_003astring_002denclosed_002dp"></a>
<p>Does <code>string</code> begin with <code>prefix</code> and end with <code>suffix</code>?
</p></dd></dl>
<a name="Function-uiop_002futility_003astring_002dprefix_002dp"></a><dl>
<dt><a name="index-string_002dprefix_002dp"></a>Function: <strong>string-prefix-p</strong> <em>prefix string</em></dt>
<dd><a name="index-uiop_002futility_003astring_002dprefix_002dp"></a>
<p>Does <code>string</code> begin with <code>prefix</code>?
</p></dd></dl>
<a name="Function-uiop_002futility_003astring_002dsuffix_002dp"></a><dl>
<dt><a name="index-string_002dsuffix_002dp"></a>Function: <strong>string-suffix-p</strong> <em>string suffix</em></dt>
<dd><a name="index-uiop_002futility_003astring_002dsuffix_002dp"></a>
<p>Does <code>string</code> end with <code>suffix</code>?
</p></dd></dl>
<a name="Function-uiop_002futility_003astrings_002dcommon_002delement_002dtype"></a><dl>
<dt><a name="index-strings_002dcommon_002delement_002dtype"></a>Function: <strong>strings-common-element-type</strong> <em>strings</em></dt>
<dd><a name="index-uiop_002futility_003astrings_002dcommon_002delement_002dtype"></a>
<p>What least subtype of <code>character</code> can contain all the elements of all the <code>strings</code>?
</p></dd></dl>
<a name="Function-uiop_002futility_003astripln"></a><dl>
<dt><a name="index-stripln"></a>Function: <strong>stripln</strong> <em>x</em></dt>
<dd><a name="index-uiop_002futility_003astripln"></a>
<p>Strip a string <code>x</code> from any ending CR, LF or CRLF.
Return two values, the stripped string and the ending that was stripped,
or the original value and <code>nil</code> if no stripping took place.
Since our <code>strcat</code> accepts <code>nil</code> as empty string designator,
the two results passed to <code>strcat</code> always reconstitute the original string
</p></dd></dl>
<a name="Macro-uiop_002futility_003aappendf"></a><dl>
<dt><a name="index-appendf"></a>Macro: <strong>appendf</strong> <em>place &amp;rest  args</em></dt>
<dd><a name="index-uiop_002futility_003aappendf"></a>
<p>Append onto list
</p></dd></dl>
<a name="Macro-uiop_002futility_003anest"></a><dl>
<dt><a name="index-nest"></a>Macro: <strong>nest</strong> <em>&amp;rest  things</em></dt>
<dd><a name="index-uiop_002futility_003anest"></a>
<p>Macro to keep code nesting and indentation under control.
</p></dd></dl>
<a name="Macro-uiop_002futility_003awhile_002dcollecting"></a><dl>
<dt><a name="index-while_002dcollecting"></a>Macro: <strong>while-collecting</strong> <em>(&amp;rest collectors) &amp;body  body</em></dt>
<dd><a name="index-uiop_002futility_003awhile_002dcollecting"></a>
<p><code>collectors</code> should be a list of names for collections.  A collector
defines a function that, when applied to an argument inside <code>body</code>, will
add its argument to the corresponding collection.  Returns multiple values,
a list for each collection, in order.
   <code>e</code>.g.,
(while-collecting (foo bar)
           (dolist (x &rsquo;((a <code>1</code>) (b <code>2</code>) (c <code>3</code>)))
             (foo (first x))
             (bar (second x))))
Returns two values: (A <code>b</code> <code>c</code>) and (<code>1</code> <code>2</code> <code>3</code>).
</p></dd></dl>
<a name="Macro-uiop_002futility_003awith_002dmuffled_002dconditions"></a><dl>
<dt><a name="index-with_002dmuffled_002dconditions"></a>Macro: <strong>with-muffled-conditions</strong> <em>(conditions) &amp;body  body</em></dt>
<dd><a name="index-uiop_002futility_003awith_002dmuffled_002dconditions"></a>
<p>Shorthand syntax for <code>call-with-muffled-conditions</code>
</p></dd></dl>
<a name="Macro-uiop_002futility_003awith_002dupgradability"></a><dl>
<dt><a name="index-with_002dupgradability"></a>Macro: <strong>with-upgradability</strong> <em>(&amp;optional) &amp;body  body</em></dt>
<dd><a name="index-uiop_002futility_003awith_002dupgradability"></a>
<p>Evaluate <code>body</code> at compile- load- and run- times, with <code>defun</code> and <code>defgeneric</code> modified
to also declare the functions <code>notinline</code> and to accept a wrapping the function name
specification into a list with keyword argument <code>supersede</code> (which defaults to <code>t</code> if the name
is not wrapped, and <code>nil</code> if it is wrapped). If <code>supersede</code> is true, call <code>undefine-function</code>
to supersede any previous definition.
</p></dd></dl>
<a name="Variable-uiop_002futility_003a_002auiop_002ddebug_002dutility_002a"></a><dl>
<dt><a name="index-_002auiop_002ddebug_002dutility_002a"></a>Variable: <strong>*uiop-debug-utility*</strong></dt>
<dd><a name="index-uiop_002futility_003a_002auiop_002ddebug_002dutility_002a"></a>
<p>form that evaluates to the pathname to your favorite debugging utilities
</p></dd></dl>

<hr>
<a name="UIOP_002fVERSION"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fOS" accesskey="n" rel="next">UIOP/OS</a>, Previous: <a href="#UIOP_002fUTILITY" accesskey="p" rel="prev">UIOP/UTILITY</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fVERSION-1"></a>
<h2 class="chapter">5 UIOP/VERSION</h2>

<a name="Function-uiop_002fversion_003anext_002dversion"></a><dl>
<dt><a name="index-next_002dversion"></a>Function: <strong>next-version</strong> <em>version</em></dt>
<dd><a name="index-uiop_002fversion_003anext_002dversion"></a>
<p>When <code>version</code> is not nil, it is a string, then parse it as a version, compute the next version
and return it as a string.
</p></dd></dl>
<a name="Function-uiop_002fversion_003aparse_002dversion"></a><dl>
<dt><a name="index-parse_002dversion"></a>Function: <strong>parse-version</strong> <em>version-string &amp;optional  on-error</em></dt>
<dd><a name="index-uiop_002fversion_003aparse_002dversion"></a>
<p>Parse a <code>version-string</code> as a series of natural numbers separated by dots.
Return a (non-null) list of integers if the string is valid;
otherwise return <code>nil</code>.
</p>
<p>When invalid, <code>on-error</code> is called as per <code>call-function</code> before to return <code>nil</code>,
with format arguments explaining why the version is invalid.
<code>on-error</code> is also called if the version is not canonical
in that it doesn&rsquo;t print back to itself, but the list is returned anyway.
</p></dd></dl>
<a name="Function-uiop_002fversion_003aunparse_002dversion"></a><dl>
<dt><a name="index-unparse_002dversion"></a>Function: <strong>unparse-version</strong> <em>version-list</em></dt>
<dd><a name="index-uiop_002fversion_003aunparse_002dversion"></a>
<p>From a parsed version (a list of natural numbers), compute the version string
</p></dd></dl>
<a name="Function-uiop_002fversion_003aversion_002ddeprecation"></a><dl>
<dt><a name="index-version_002ddeprecation"></a>Function: <strong>version-deprecation</strong> <em>version &amp;key  style-warning warning error delete</em></dt>
<dd><a name="index-uiop_002fversion_003aversion_002ddeprecation"></a>
<p>Given a <code>version</code> string, and the starting versions for notifying the programmer of
various levels of deprecation, return the current level of deprecation as per <code>with-deprecation</code>
that is the highest level that has a declared version older than the specified version.
Each start version for a level of deprecation can be specified by a keyword argument, or
if left unspecified, will be the <code>next-version</code> of the immediate lower level of deprecation.
</p></dd></dl>
<a name="Function-uiop_002fversion_003aversion_003c_003d"></a><dl>
<dt><a name="index-version_003c_003d"></a>Function: <strong>version&lt;=</strong> <em>version1 version2</em></dt>
<dd><a name="index-uiop_002fversion_003aversion_003c_003d"></a>
<p>Given two version strings, return <code>t</code> if the second is newer or the same
</p></dd></dl>
<a name="Function-uiop_002fversion_003aversion_003c"></a><dl>
<dt><a name="index-version_003c"></a>Function: <strong>version&lt;</strong> <em>version1 version2</em></dt>
<dd><a name="index-uiop_002fversion_003aversion_003c"></a>
<p>Given two version strings, return <code>t</code> if the second is strictly newer
</p></dd></dl>
<a name="Macro-uiop_002fversion_003awith_002ddeprecation"></a><dl>
<dt><a name="index-with_002ddeprecation"></a>Macro: <strong>with-deprecation</strong> <em>(level) &amp;body  definitions</em></dt>
<dd><a name="index-uiop_002fversion_003awith_002ddeprecation"></a>
<p>Given a deprecation <code>level</code> (a form to be <code>eval</code>&rsquo;ed at macro-expansion time), instrument the
<code>defun</code> and <code>defmethod</code> forms in <code>definitions</code> to notify the programmer of the deprecation of the function
when it is compiled or called.
</p>
<p>Increasing levels (as result from evaluating <code>level</code>) are: <code>nil</code> (not deprecated yet),
<code>:style-warning</code> (a style warning is issued when used), <code>:warning</code> (a full warning is issued when used),
<code>:error</code> (a continuable error instead), and <code>:delete</code> (it&rsquo;s an error if the code is still there while
at that level).
</p>
<p>Forms other than <code>defun</code> and <code>defmethod</code> are not instrumented, and you can protect a <code>defun</code> or <code>defmethod</code>
from instrumentation by enclosing it in a <code>progn</code>.
</p></dd></dl>

<hr>
<a name="UIOP_002fOS"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fPATHNAME" accesskey="n" rel="next">UIOP/PATHNAME</a>, Previous: <a href="#UIOP_002fVERSION" accesskey="p" rel="prev">UIOP/VERSION</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fOS-1"></a>
<h2 class="chapter">6 UIOP/OS</h2>

<a name="Function-uiop_002fos_003aarchitecture"></a><dl>
<dt><a name="index-architecture"></a>Function: <strong>architecture</strong></dt>
<dd><a name="index-uiop_002fos_003aarchitecture"></a>
<p>The CPU architecture of the current host
</p></dd></dl>
<a name="Function-uiop_002fos_003achdir"></a><dl>
<dt><a name="index-chdir"></a>Function: <strong>chdir</strong> <em>x</em></dt>
<dd><a name="index-uiop_002fos_003achdir"></a>
<p>Change current directory, as per POSIX chdir(<code>2</code>), to a given pathname object
</p></dd></dl>
<a name="Function-uiop_002fos_003adetect_002dos"></a><dl>
<dt><a name="index-detect_002dos"></a>Function: <strong>detect-os</strong></dt>
<dd><a name="index-uiop_002fos_003adetect_002dos"></a>
<p>Detects the current operating system. Only needs be run at compile-time,
except on ABCL where it might change between FASL compilation and runtime.
</p></dd></dl>
<a name="Function-uiop_002fos_003afeaturep"></a><dl>
<dt><a name="index-featurep"></a>Function: <strong>featurep</strong> <em>x &amp;optional  *features*</em></dt>
<dd><a name="index-uiop_002fos_003afeaturep"></a>
<p>Checks whether a feature expression <code>x</code> is true with respect to the <code>*features*</code> set,
as per the CLHS standard for <code>#+</code> and <code>#-</code>. Beware that just like the CLHS,
we assume symbols from the <code>keyword</code> package are used, but that unless you&rsquo;re using #+/#-
your reader will not have magically used the <code>keyword</code> package, so you need specify
keywords explicitly.
</p></dd></dl>
<a name="Function-uiop_002fos_003agetcwd"></a><dl>
<dt><a name="index-getcwd"></a>Function: <strong>getcwd</strong></dt>
<dd><a name="index-uiop_002fos_003agetcwd"></a>
<p>Get the current working directory as per POSIX getcwd(<code>3</code>), as a pathname object
</p></dd></dl>
<a name="Function-uiop_002fos_003agetenv"></a><dl>
<dt><a name="index-getenv"></a>Function: <strong>getenv</strong> <em>x</em></dt>
<dd><a name="index-uiop_002fos_003agetenv"></a>
<p>Query the environment, as in <code>c</code> getenv.
Beware: may return empty string if a variable is present but empty;
use getenvp to return <code>nil</code> in such a case.
</p></dd></dl>
<a name="Function-uiop_002fos_003agetenvp"></a><dl>
<dt><a name="index-getenvp"></a>Function: <strong>getenvp</strong> <em>x</em></dt>
<dd><a name="index-uiop_002fos_003agetenvp"></a>
<p>Predicate that is true if the named variable is present in the libc environment,
then returning the non-empty string value of the variable
</p></dd></dl>
<a name="Function-uiop_002fos_003ahostname"></a><dl>
<dt><a name="index-hostname"></a>Function: <strong>hostname</strong></dt>
<dd><a name="index-uiop_002fos_003ahostname"></a>
<p>return the hostname of the current host
</p></dd></dl>
<a name="Function-uiop_002fos_003aimplementation_002didentifier"></a><dl>
<dt><a name="index-implementation_002didentifier"></a>Function: <strong>implementation-identifier</strong></dt>
<dd><a name="index-uiop_002fos_003aimplementation_002didentifier"></a>
<p>Return a string that identifies the <code>abi</code> of the current implementation,
suitable for use as a directory name to segregate Lisp FASLs, <code>c</code> dynamic libraries, etc.
</p></dd></dl>
<a name="Function-uiop_002fos_003aimplementation_002dtype"></a><dl>
<dt><a name="index-implementation_002dtype"></a>Function: <strong>implementation-type</strong></dt>
<dd><a name="index-uiop_002fos_003aimplementation_002dtype"></a>
<p>The type of Lisp implementation used, as a short UIOP-standardized keyword
</p></dd></dl>
<a name="Function-uiop_002fos_003alisp_002dversion_002dstring"></a><dl>
<dt><a name="index-lisp_002dversion_002dstring"></a>Function: <strong>lisp-version-string</strong></dt>
<dd><a name="index-uiop_002fos_003alisp_002dversion_002dstring"></a>
<p>return a string that identifies the current Lisp implementation version
</p></dd></dl>
<a name="Function-uiop_002fos_003aoperating_002dsystem"></a><dl>
<dt><a name="index-operating_002dsystem"></a>Function: <strong>operating-system</strong></dt>
<dd><a name="index-uiop_002fos_003aoperating_002dsystem"></a>
<p>The operating system of the current host
</p></dd></dl>
<a name="Function-uiop_002fos_003aos_002dgenera_002dp"></a><dl>
<dt><a name="index-os_002dgenera_002dp"></a>Function: <strong>os-genera-p</strong></dt>
<dd><a name="index-uiop_002fos_003aos_002dgenera_002dp"></a>
<p>Is the underlying operating system Genera (running on a Symbolics Lisp Machine)?
</p></dd></dl>
<a name="Function-uiop_002fos_003aos_002dmacosx_002dp"></a><dl>
<dt><a name="index-os_002dmacosx_002dp"></a>Function: <strong>os-macosx-p</strong></dt>
<dd><a name="index-uiop_002fos_003aos_002dmacosx_002dp"></a>
<p>Is the underlying operating system MacOS <code>x</code>?
</p></dd></dl>
<a name="Function-uiop_002fos_003aos_002dunix_002dp"></a><dl>
<dt><a name="index-os_002dunix_002dp"></a>Function: <strong>os-unix-p</strong></dt>
<dd><a name="index-uiop_002fos_003aos_002dunix_002dp"></a>
<p>Is the underlying operating system some Unix variant?
</p></dd></dl>
<a name="Function-uiop_002fos_003aos_002dwindows_002dp"></a><dl>
<dt><a name="index-os_002dwindows_002dp"></a>Function: <strong>os-windows-p</strong></dt>
<dd><a name="index-uiop_002fos_003aos_002dwindows_002dp"></a>
<p>Is the underlying operating system Microsoft Windows?
</p></dd></dl>
<a name="Function-uiop_002fos_003aparse_002dfile_002dlocation_002dinfo"></a><dl>
<dt><a name="index-parse_002dfile_002dlocation_002dinfo"></a>Function: <strong>parse-file-location-info</strong> <em>s</em></dt>
<dd><a name="index-uiop_002fos_003aparse_002dfile_002dlocation_002dinfo"></a>
<p>helper to parse-windows-shortcut
</p></dd></dl>
<a name="Function-uiop_002fos_003aparse_002dwindows_002dshortcut"></a><dl>
<dt><a name="index-parse_002dwindows_002dshortcut"></a>Function: <strong>parse-windows-shortcut</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002fos_003aparse_002dwindows_002dshortcut"></a>
<p>From a .lnk windows shortcut, extract the pathname linked to
</p></dd></dl>
<a name="Function-uiop_002fos_003aread_002dlittle_002dendian"></a><dl>
<dt><a name="index-read_002dlittle_002dendian"></a>Function: <strong>read-little-endian</strong> <em>s &amp;optional  bytes</em></dt>
<dd><a name="index-uiop_002fos_003aread_002dlittle_002dendian"></a>
<p>Read a number in little-endian format from an byte (octet) stream <code>s</code>,
the number having <code>bytes</code> octets (defaulting to <code>4</code>).
</p></dd></dl>
<a name="Function-uiop_002fos_003aread_002dnull_002dterminated_002dstring"></a><dl>
<dt><a name="index-read_002dnull_002dterminated_002dstring"></a>Function: <strong>read-null-terminated-string</strong> <em>s</em></dt>
<dd><a name="index-uiop_002fos_003aread_002dnull_002dterminated_002dstring"></a>
<p>Read a null-terminated string from an octet stream <code>s</code>
</p></dd></dl>
<a name="Setf_002dExpander-uiop_002fos_003agetenv"></a><dl>
<dt><a name="index-getenv-1"></a>Setf Expander: <strong>getenv</strong> <em>x</em></dt>
<dd><p>Set an environment variable.
</p></dd></dl>
<a name="Variable-uiop_002fos_003a_002aimplementation_002dtype_002a"></a><dl>
<dt><a name="index-_002aimplementation_002dtype_002a"></a>Variable: <strong>*implementation-type*</strong></dt>
<dd><a name="index-uiop_002fos_003a_002aimplementation_002dtype_002a"></a>
<p>The type of Lisp implementation used, as a short UIOP-standardized keyword
</p></dd></dl>

<hr>
<a name="UIOP_002fPATHNAME"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fFILESYSTEM" accesskey="n" rel="next">UIOP/FILESYSTEM</a>, Previous: <a href="#UIOP_002fOS" accesskey="p" rel="prev">UIOP/OS</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fPATHNAME-1"></a>
<h2 class="chapter">7 UIOP/PATHNAME</h2>

<a name="Function-uiop_002fpathname_003aabsolute_002dpathname_002dp"></a><dl>
<dt><a name="index-absolute_002dpathname_002dp"></a>Function: <strong>absolute-pathname-p</strong> <em>pathspec</em></dt>
<dd><a name="index-uiop_002fpathname_003aabsolute_002dpathname_002dp"></a>
<p>If <code>pathspec</code> is a pathname or namestring object that parses as a pathname
possessing an <code>:absolute</code> directory component, return the (parsed) pathname.
Otherwise return <code>nil</code>
</p></dd></dl>
<a name="Function-uiop_002fpathname_003acall_002dwith_002denough_002dpathname"></a><dl>
<dt><a name="index-call_002dwith_002denough_002dpathname"></a>Function: <strong>call-with-enough-pathname</strong> <em>maybe-subpath defaults-pathname thunk</em></dt>
<dd><a name="index-uiop_002fpathname_003acall_002dwith_002denough_002dpathname"></a>
<p>In a context where <code>*default-pathname-defaults*</code> is bound to <code>defaults-pathname</code> (if not null,
or else to its current value), call <code>thunk</code> with <code>enough-pathname</code> for <code>maybe-subpath</code>
given <code>defaults-pathname</code> as a base pathname.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003adenormalize_002dpathname_002ddirectory_002dcomponent"></a><dl>
<dt><a name="index-denormalize_002dpathname_002ddirectory_002dcomponent"></a>Function: <strong>denormalize-pathname-directory-component</strong> <em>directory-component</em></dt>
<dd><a name="index-uiop_002fpathname_003adenormalize_002dpathname_002ddirectory_002dcomponent"></a>
<p>Convert the <code>directory-component</code> from a CLHS-standard format to a format usable
by the underlying implementation&rsquo;s <code>make-pathname</code> and other primitives
</p></dd></dl>
<a name="Function-uiop_002fpathname_003adirectorize_002dpathname_002dhost_002ddevice"></a><dl>
<dt><a name="index-directorize_002dpathname_002dhost_002ddevice"></a>Function: <strong>directorize-pathname-host-device</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002fpathname_003adirectorize_002dpathname_002dhost_002ddevice"></a>
<p>Given a <code>pathname</code>, return a pathname that has representations of its <code>host</code> and <code>device</code> components
added to its <code>directory</code> component. This is useful for output translations.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003adirectory_002dpathname_002dp"></a><dl>
<dt><a name="index-directory_002dpathname_002dp"></a>Function: <strong>directory-pathname-p</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002fpathname_003adirectory_002dpathname_002dp"></a>
<p>Does <code>pathname</code> represent a directory?
</p>
<p>A directory-pathname is a pathname _without_ a filename. The three
ways that the filename components can be missing are for it to be <code>nil</code>,
<code>:unspecific</code> or the empty string.
</p>
<p>Note that this does _not_ check to see that <code>pathname</code> points to an
actually-existing directory.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003adirectory_002dseparator_002dfor_002dhost"></a><dl>
<dt><a name="index-directory_002dseparator_002dfor_002dhost"></a>Function: <strong>directory-separator-for-host</strong> <em>&amp;optional  pathname</em></dt>
<dd><a name="index-uiop_002fpathname_003adirectory_002dseparator_002dfor_002dhost"></a>
<p>Given a <code>pathname</code>, return the character used to delimit directory names on this host and device.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003aenough_002dpathname"></a><dl>
<dt><a name="index-enough_002dpathname"></a>Function: <strong>enough-pathname</strong> <em>maybe-subpath base-pathname</em></dt>
<dd><a name="index-uiop_002fpathname_003aenough_002dpathname"></a>
<p>if <code>maybe-subpath</code> is a pathname that is under <code>base-pathname</code>, return a pathname object that
when used with <code>merge-pathnames*</code> with defaults <code>base-pathname</code>, returns <code>maybe-subpath</code>.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003aensure_002dabsolute_002dpathname"></a><dl>
<dt><a name="index-ensure_002dabsolute_002dpathname"></a>Function: <strong>ensure-absolute-pathname</strong> <em>path &amp;optional  defaults on-error</em></dt>
<dd><a name="index-uiop_002fpathname_003aensure_002dabsolute_002dpathname"></a>
<p>Given a pathname designator <code>path</code>, return an absolute pathname as specified by <code>path</code>
considering the <code>defaults</code>, or, if not possible, use <code>call-function</code> on the specified <code>on-error</code> behavior,
with a format control-string and other arguments as arguments
</p></dd></dl>
<a name="Function-uiop_002fpathname_003aensure_002ddirectory_002dpathname"></a><dl>
<dt><a name="index-ensure_002ddirectory_002dpathname"></a>Function: <strong>ensure-directory-pathname</strong> <em>pathspec &amp;optional  on-error</em></dt>
<dd><a name="index-uiop_002fpathname_003aensure_002ddirectory_002dpathname"></a>
<p>Converts the non-wild pathname designator <code>pathspec</code> to directory form.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003aensure_002dpathname"></a><dl>
<dt><a name="index-ensure_002dpathname"></a>Function: <strong>ensure-pathname</strong> <em>pathname &amp;key  on-error defaults type dot-dot namestring empty-is-nil want-pathname want-logical want-physical ensure-physical want-relative want-absolute ensure-absolute ensure-subpath want-non-wild want-wild wilden want-file want-directory ensure-directory want-existing ensure-directories-exist truename resolve-symlinks truenamize &amp;aux p</em></dt>
<dd><a name="index-uiop_002fpathname_003aensure_002dpathname"></a>
<p>Coerces its argument into a <code>pathname</code>,
optionally doing some transformations and checking specified constraints.
</p>
<p>If the argument is <code>nil</code>, then <code>nil</code> is returned unless the <code>want-pathname</code> constraint is specified.
</p>
<p>If the argument is a <code>string</code>, it is first converted to a pathname via
<code>parse-unix-namestring</code>, <code>parse-namestring</code> or <code>parse-native-namestring</code> respectively
depending on the <code>namestring</code> argument being <code>:unix</code>, <code>:lisp</code> or <code>:native</code> respectively,
or else by using <code>call-function</code> on the <code>namestring</code> argument;
if <code>:unix</code> is specified (or <code>nil</code>, the default, which specifies the same thing),
then <code>parse-unix-namestring</code> it is called with the keywords
<code>defaults</code> <code>type</code> <code>dot-dot</code> <code>ensure-directory</code> <code>want-relative</code>, and
the result is optionally merged into the <code>defaults</code> if <code>ensure-absolute</code> is true.
</p>
<p>The pathname passed or resulting from parsing the string
is then subjected to all the checks and transformations below are run.
</p>
<p>Each non-nil constraint argument can be one of the symbols <code>t</code>, <code>error</code>, <code>cerror</code> or <code>ignore</code>.
The boolean <code>t</code> is an alias for <code>error</code>.
<code>error</code> means that an error will be raised if the constraint is not satisfied.
<code>cerror</code> means that an continuable error will be raised if the constraint is not satisfied.
<code>ignore</code> means just return <code>nil</code> instead of the pathname.
</p>
<p>The <code>on-error</code> argument, if not <code>nil</code>, is a function designator (as per <code>call-function</code>)
that will be called with the the following arguments:
a generic format string for ensure pathname, the pathname,
the keyword argument corresponding to the failed check or transformation,
a format string for the reason <code>ensure-pathname</code> failed,
and a list with arguments to that format string.
If <code>on-error</code> is <code>nil</code>, <code>error</code> is used instead, which does the right thing.
You could also pass (<code>cerror</code> &quot;<code>continue</code> <code>despite</code> <code>failed</code> <code>check</code>&quot;).
</p>
<p>The transformations and constraint checks are done in this order,
which is also the order in the lambda-list:
</p>
<p><code>empty-is-nil</code> returns <code>nil</code> if the argument is an empty string.
<code>want-pathname</code> checks that pathname (after parsing if needed) is not null.
Otherwise, if the pathname is <code>nil</code>, ensure-pathname returns <code>nil</code>.
<code>want-logical</code> checks that pathname is a <code>logical-pathname</code>
<code>want-physical</code> checks that pathname is not a <code>logical-pathname</code>
<code>ensure-physical</code> ensures that pathname is physical via <code>translate-logical-pathname</code>
<code>want-relative</code> checks that pathname has a relative directory component
<code>want-absolute</code> checks that pathname does have an absolute directory component
<code>ensure-absolute</code> merges with the <code>defaults</code>, then checks again
that the result absolute is an absolute pathname indeed.
<code>ensure-subpath</code> checks that the pathname is a subpath of the <code>defaults</code>.
<code>want-file</code> checks that pathname has a non-nil <code>file</code> component
<code>want-directory</code> checks that pathname has nil <code>file</code> and <code>type</code> components
<code>ensure-directory</code> uses <code>ensure-directory-pathname</code> to interpret
any file and type components as being actually a last directory component.
<code>want-non-wild</code> checks that pathname is not a wild pathname
<code>want-wild</code> checks that pathname is a wild pathname
<code>wilden</code> merges the pathname with **/*.<code>*</code>.<code>*</code> if it is not wild
<code>want-existing</code> checks that a file (or directory) exists with that pathname.
<code>ensure-directories-exist</code> creates any parent directory with <code>ensure-directories-exist</code>.
<code>truename</code> replaces the pathname by its truename, or errors if not possible.
<code>resolve-symlinks</code> replaces the pathname by a variant with symlinks resolved by <code>resolve-symlinks</code>.
<code>truenamize</code> uses <code>truenamize</code> to resolve as many symlinks as possible.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003afile_002dpathname_002dp"></a><dl>
<dt><a name="index-file_002dpathname_002dp"></a>Function: <strong>file-pathname-p</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002fpathname_003afile_002dpathname_002dp"></a>
<p>Does <code>pathname</code> represent a file, i.e. has a non-null <code>name</code> component?
</p>
<p>Accepts <code>nil</code>, a string (converted through <code>parse-namestring</code>) or a <code>pathname</code>.
</p>
<p>Note that this does _not_ check to see that <code>pathname</code> points to an
actually-existing file.
</p>
<p>Returns the (parsed) <code>pathname</code> when true
</p></dd></dl>
<a name="Function-uiop_002fpathname_003ahidden_002dpathname_002dp"></a><dl>
<dt><a name="index-hidden_002dpathname_002dp"></a>Function: <strong>hidden-pathname-p</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002fpathname_003ahidden_002dpathname_002dp"></a>
<p>Return a boolean that is true if the pathname is hidden as per Unix style,
i.e. its name starts with a dot.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003alogical_002dpathname_002dp"></a><dl>
<dt><a name="index-logical_002dpathname_002dp"></a>Function: <strong>logical-pathname-p</strong> <em>x</em></dt>
<dd><a name="index-uiop_002fpathname_003alogical_002dpathname_002dp"></a>
<p>is <code>x</code> a logical-pathname?
</p></dd></dl>
<a name="Function-uiop_002fpathname_003amake_002dpathname_002dcomponent_002dlogical"></a><dl>
<dt><a name="index-make_002dpathname_002dcomponent_002dlogical"></a>Function: <strong>make-pathname-component-logical</strong> <em>x</em></dt>
<dd><a name="index-uiop_002fpathname_003amake_002dpathname_002dcomponent_002dlogical"></a>
<p>Make a pathname component suitable for use in a logical-pathname
</p></dd></dl>
<a name="Function-uiop_002fpathname_003amake_002dpathname_002dlogical"></a><dl>
<dt><a name="index-make_002dpathname_002dlogical"></a>Function: <strong>make-pathname-logical</strong> <em>pathname host</em></dt>
<dd><a name="index-uiop_002fpathname_003amake_002dpathname_002dlogical"></a>
<p>Take a <code>pathname</code>&rsquo;s directory, name, type and version components,
and make a new pathname with corresponding components and specified logical <code>host</code>
</p></dd></dl>
<a name="Function-uiop_002fpathname_003amake_002dpathname_002a"></a><dl>
<dt><a name="index-make_002dpathname_002a"></a>Function: <strong>make-pathname*</strong> <em>&amp;rest  keys &amp;key  directory host device name type version defaults</em></dt>
<dd><a name="index-uiop_002fpathname_003amake_002dpathname_002a"></a>
<p>Takes arguments like <code>cl:make-pathname</code> in the CLHS, and
   tries hard to make a pathname that will actually behave as documented,
   despite the peculiarities of each implementation. <code>deprecated:</code> just use <code>make-pathname</code>.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003amerge_002dpathname_002ddirectory_002dcomponents"></a><dl>
<dt><a name="index-merge_002dpathname_002ddirectory_002dcomponents"></a>Function: <strong>merge-pathname-directory-components</strong> <em>specified defaults</em></dt>
<dd><a name="index-uiop_002fpathname_003amerge_002dpathname_002ddirectory_002dcomponents"></a>
<p>Helper for <code>merge-pathnames*</code> that handles directory components
</p></dd></dl>
<a name="Function-uiop_002fpathname_003amerge_002dpathnames_002a"></a><dl>
<dt><a name="index-merge_002dpathnames_002a"></a>Function: <strong>merge-pathnames*</strong> <em>specified &amp;optional  defaults</em></dt>
<dd><a name="index-uiop_002fpathname_003amerge_002dpathnames_002a"></a>
<p><code>merge-pathnames*</code> is like <code>merge-pathnames</code> except that
if the <code>specified</code> pathname does not have an absolute directory,
then the <code>host</code> and <code>device</code> both come from the <code>defaults</code>, whereas
if the <code>specified</code> pathname does have an absolute directory,
then the <code>host</code> and <code>device</code> both come from the <code>specified</code> pathname.
This is what users want on a modern Unix or Windows operating system,
unlike the <code>merge-pathnames</code> behavior.
Also, if either argument is <code>nil</code>, then the other argument is returned unmodified;
this is unlike <code>merge-pathnames</code> which always merges with a pathname,
by default <code>*default-pathname-defaults*</code>, which cannot be <code>nil</code>.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003anil_002dpathname"></a><dl>
<dt><a name="index-nil_002dpathname"></a>Function: <strong>nil-pathname</strong> <em>&amp;optional  defaults</em></dt>
<dd><a name="index-uiop_002fpathname_003anil_002dpathname"></a>
<p>A pathname that is as neutral as possible for use as defaults
when merging, making or parsing pathnames
</p></dd></dl>
<a name="Function-uiop_002fpathname_003anormalize_002dpathname_002ddirectory_002dcomponent"></a><dl>
<dt><a name="index-normalize_002dpathname_002ddirectory_002dcomponent"></a>Function: <strong>normalize-pathname-directory-component</strong> <em>directory</em></dt>
<dd><a name="index-uiop_002fpathname_003anormalize_002dpathname_002ddirectory_002dcomponent"></a>
<p>Convert the <code>directory</code> component from a format usable by the underlying
implementation&rsquo;s <code>make-pathname</code> and other primitives to a CLHS-standard format
that is a list and not a string.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003aparse_002dunix_002dnamestring"></a><dl>
<dt><a name="index-parse_002dunix_002dnamestring"></a>Function: <strong>parse-unix-namestring</strong> <em>name &amp;rest  keys &amp;key  type defaults dot-dot ensure-directory &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002fpathname_003aparse_002dunix_002dnamestring"></a>
<p>Coerce <code>name</code> into a <code>pathname</code> using standard Unix syntax.
</p>
<p>Unix syntax is used whether or not the underlying system is Unix;
on such non-Unix systems it is reliably usable only for relative pathnames.
This function is especially useful to manipulate relative pathnames portably,
where it is of crucial to possess a portable pathname syntax independent of the underlying OS.
This is what <code>parse-unix-namestring</code> provides, and why we use it in ASDF.
</p>
<p>When given a <code>pathname</code> object, just return it untouched.
When given <code>nil</code>, just return <code>nil</code>.
When given a non-null <code>symbol</code>, first downcase its name and treat it as a string.
When given a <code>string</code>, portably decompose it into a pathname as below.
</p>
<p>#\/ separates directory components.
</p>
<p>The last #\/-separated substring is interpreted as follows:
<code>1-</code> If <code>type</code> is <code>:directory</code> or <code>ensure-directory</code> is true,
 the string is made the last directory component, and <code>name</code> and <code>type</code> are <code>nil</code>.
 if the string is empty, it&rsquo;s the empty pathname with all slots <code>nil</code>.
<code>2-</code> If <code>type</code> is <code>nil</code>, the substring is a file-namestring, and its <code>name</code> and <code>type</code>
 are separated by <code>split-name-type</code>.
<code>3-</code> If <code>type</code> is a string, it is the given <code>type</code>, and the whole string is the <code>name</code>.
</p>
<p>Directory components with an empty name or the name &quot;.&quot; are removed.
Any directory named &quot;..&quot; is read as <code>dot-dot</code>,
which must be one of <code>:back</code> or <code>:up</code> and defaults to <code>:back</code>.
</p>
<p><code>host</code>, <code>device</code> and <code>version</code> components are taken from <code>defaults</code>,
which itself defaults to <code>*nil-pathname*</code>, also used if <code>defaults</code> is <code>nil</code>.
No host or device can be specified in the string itself,
which makes it unsuitable for absolute pathnames outside Unix.
</p>
<p>For relative pathnames, these components (and hence the defaults) won&rsquo;t matter
if you use <code>merge-pathnames*</code> but will matter if you use <code>merge-pathnames</code>,
which is an important reason to always use <code>merge-pathnames*</code>.
</p>
<p>Arbitrary keys are accepted, and the parse result is passed to <code>ensure-pathname</code>
with those keys, removing <code>type</code> <code>defaults</code> and <code>dot-dot</code>.
When you&rsquo;re manipulating pathnames that are supposed to make sense portably
even though the OS may not be Unixish, we recommend you use <code>:want-relative</code> <code>t</code>
to throw an error if the pathname is absolute
</p></dd></dl>
<a name="Function-uiop_002fpathname_003apathname_002ddirectory_002dpathname"></a><dl>
<dt><a name="index-pathname_002ddirectory_002dpathname"></a>Function: <strong>pathname-directory-pathname</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002fpathname_003apathname_002ddirectory_002dpathname"></a>
<p>Returns a new pathname with same <code>host</code>, <code>device</code>, <code>directory</code> as <code>pathname</code>,
and <code>nil</code> <code>name</code>, <code>type</code> and <code>version</code> components
</p></dd></dl>
<a name="Function-uiop_002fpathname_003apathname_002dequal"></a><dl>
<dt><a name="index-pathname_002dequal"></a>Function: <strong>pathname-equal</strong> <em>p1 p2</em></dt>
<dd><a name="index-uiop_002fpathname_003apathname_002dequal"></a>
<p>Are the two pathnames <code>p1</code> and <code>p2</code> reasonably equal in the paths they denote?
</p></dd></dl>
<a name="Function-uiop_002fpathname_003apathname_002dhost_002dpathname"></a><dl>
<dt><a name="index-pathname_002dhost_002dpathname"></a>Function: <strong>pathname-host-pathname</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002fpathname_003apathname_002dhost_002dpathname"></a>
<p>return a pathname with the same host as given <code>pathname</code>, and all other fields <code>nil</code>
</p></dd></dl>
<a name="Function-uiop_002fpathname_003apathname_002dparent_002ddirectory_002dpathname"></a><dl>
<dt><a name="index-pathname_002dparent_002ddirectory_002dpathname"></a>Function: <strong>pathname-parent-directory-pathname</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002fpathname_003apathname_002dparent_002ddirectory_002dpathname"></a>
<p>Returns a new pathname that corresponds to the parent of the current pathname&rsquo;s directory,
i.e. removing one level of depth in the <code>directory</code> component. e.g. if pathname is
Unix pathname /foo/bar/baz/file.type then return /foo/bar/
</p></dd></dl>
<a name="Function-uiop_002fpathname_003apathname_002droot"></a><dl>
<dt><a name="index-pathname_002droot"></a>Function: <strong>pathname-root</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002fpathname_003apathname_002droot"></a>
<p>return the root directory for the host and device of given <code>pathname</code>
</p></dd></dl>
<a name="Function-uiop_002fpathname_003aphysical_002dpathname_002dp"></a><dl>
<dt><a name="index-physical_002dpathname_002dp"></a>Function: <strong>physical-pathname-p</strong> <em>x</em></dt>
<dd><a name="index-uiop_002fpathname_003aphysical_002dpathname_002dp"></a>
<p>is <code>x</code> a pathname that is not a logical-pathname?
</p></dd></dl>
<a name="Function-uiop_002fpathname_003aphysicalize_002dpathname"></a><dl>
<dt><a name="index-physicalize_002dpathname"></a>Function: <strong>physicalize-pathname</strong> <em>x</em></dt>
<dd><a name="index-uiop_002fpathname_003aphysicalize_002dpathname"></a>
<p>if <code>x</code> is a logical pathname, use translate-logical-pathname on it.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003arelative_002dpathname_002dp"></a><dl>
<dt><a name="index-relative_002dpathname_002dp"></a>Function: <strong>relative-pathname-p</strong> <em>pathspec</em></dt>
<dd><a name="index-uiop_002fpathname_003arelative_002dpathname_002dp"></a>
<p>If <code>pathspec</code> is a pathname or namestring object that parses as a pathname
possessing a <code>:relative</code> or <code>nil</code> directory component, return the (parsed) pathname.
Otherwise return <code>nil</code>
</p></dd></dl>
<a name="Function-uiop_002fpathname_003arelativize_002ddirectory_002dcomponent"></a><dl>
<dt><a name="index-relativize_002ddirectory_002dcomponent"></a>Function: <strong>relativize-directory-component</strong> <em>directory-component</em></dt>
<dd><a name="index-uiop_002fpathname_003arelativize_002ddirectory_002dcomponent"></a>
<p>Given the <code>directory-component</code> of a pathname, return an otherwise similar relative directory component
</p></dd></dl>
<a name="Function-uiop_002fpathname_003arelativize_002dpathname_002ddirectory"></a><dl>
<dt><a name="index-relativize_002dpathname_002ddirectory"></a>Function: <strong>relativize-pathname-directory</strong> <em>pathspec</em></dt>
<dd><a name="index-uiop_002fpathname_003arelativize_002dpathname_002ddirectory"></a>
<p>Given a <code>pathname</code>, return a relative pathname with otherwise the same components
</p></dd></dl>
<a name="Function-uiop_002fpathname_003asplit_002dname_002dtype"></a><dl>
<dt><a name="index-split_002dname_002dtype"></a>Function: <strong>split-name-type</strong> <em>filename</em></dt>
<dd><a name="index-uiop_002fpathname_003asplit_002dname_002dtype"></a>
<p>Split a filename into two values <code>name</code> and <code>type</code> that are returned.
We assume filename has no directory component.
The last . if any separates name and type from from type,
except that if there is only one . and it is in first position,
the whole filename is the <code>name</code> with an empty type.
<code>name</code> is always a string.
For an empty type, <code>*unspecific-pathname-type*</code> is returned.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003asplit_002dunix_002dnamestring_002ddirectory_002dcomponents"></a><dl>
<dt><a name="index-split_002dunix_002dnamestring_002ddirectory_002dcomponents"></a>Function: <strong>split-unix-namestring-directory-components</strong> <em>unix-namestring &amp;key  ensure-directory dot-dot</em></dt>
<dd><a name="index-uiop_002fpathname_003asplit_002dunix_002dnamestring_002ddirectory_002dcomponents"></a>
<p>Splits the path string <code>unix-namestring</code>, returning four values:
A flag that is either :absolute or :relative, indicating
   how the rest of the values are to be interpreted.
A directory path <code>---</code> a list of strings and keywords, suitable for
   use with <code>make-pathname</code> when prepended with the flag value.
   Directory components with an empty name or the name . are removed.
   Any directory named .. is read as <code>dot-dot</code>, or <code>:back</code> if it&rsquo;s <code>nil</code> (not <code>:up</code>).
A last-component, either a file-namestring including type extension,
   or <code>nil</code> in the case of a directory pathname.
A flag that is true iff the unix-style-pathname was just
   a file-namestring without / path specification.
<code>ensure-directory</code> forces the namestring to be interpreted as a directory pathname:
the third return value will be <code>nil</code>, and final component of the namestring
will be treated as part of the directory path.
</p>
<p>An empty string is thus read as meaning a pathname object with all fields nil.
</p>
<p>Note that colon characters <code>#:</code> will <code>not</code> be interpreted as host specification.
Absolute pathnames are only appropriate on Unix-style systems.
</p>
<p>The intention of this function is to support structured component names,
e.g., (:file &quot;foo/bar&quot;), which will be unpacked to relative pathnames.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003asubpathname_002a"></a><dl>
<dt><a name="index-subpathname_002a"></a>Function: <strong>subpathname*</strong> <em>pathname subpath &amp;key  type</em></dt>
<dd><a name="index-uiop_002fpathname_003asubpathname_002a"></a>
<p>returns <code>nil</code> if the base pathname is <code>nil</code>, otherwise like <code>subpathname</code>.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003asubpathname"></a><dl>
<dt><a name="index-subpathname"></a>Function: <strong>subpathname</strong> <em>pathname subpath &amp;key  type</em></dt>
<dd><a name="index-uiop_002fpathname_003asubpathname"></a>
<p>This function takes a <code>pathname</code> and a <code>subpath</code> and a <code>type</code>.
If <code>subpath</code> is already a <code>pathname</code> object (not namestring),
and is an absolute pathname at that, it is returned unchanged;
otherwise, <code>subpath</code> is turned into a relative pathname with given <code>type</code>
as per <code>parse-unix-namestring</code> with <code>:want-relative</code> <code>t</code> <code>:type</code> <code>type</code>,
then it is merged with the <code>pathname-directory-pathname</code> of <code>pathname</code>.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003asubpathp"></a><dl>
<dt><a name="index-subpathp"></a>Function: <strong>subpathp</strong> <em>maybe-subpath base-pathname</em></dt>
<dd><a name="index-uiop_002fpathname_003asubpathp"></a>
<p>if <code>maybe-subpath</code> is a pathname that is under <code>base-pathname</code>, return a pathname object that
when used with <code>merge-pathnames*</code> with defaults <code>base-pathname</code>, returns <code>maybe-subpath</code>.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003atranslate_002dpathname_002a"></a><dl>
<dt><a name="index-translate_002dpathname_002a"></a>Function: <strong>translate-pathname*</strong> <em>path absolute-source destination &amp;optional  root source</em></dt>
<dd><a name="index-uiop_002fpathname_003atranslate_002dpathname_002a"></a>
<p>A wrapper around <code>translate-pathname</code> to be used by the ASDF output-translations facility.
<code>path</code> is the pathname to be translated.
<code>absolute-source</code> is an absolute pathname to use as source for translate-pathname,
<code>destination</code> is either a function, to be called with <code>path</code> and <code>absolute-source</code>,
or a relative pathname, to be merged with <code>root</code> and used as destination for translate-pathname
or an absolute pathname, to be used as destination for translate-pathname.
In that last case, if <code>root</code> is non-NIL, <code>path</code> is first transformated by <code>directorize-pathname-host-device</code>.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003aunix_002dnamestring"></a><dl>
<dt><a name="index-unix_002dnamestring"></a>Function: <strong>unix-namestring</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002fpathname_003aunix_002dnamestring"></a>
<p>Given a non-wild <code>pathname</code>, return a Unix-style namestring for it.
If the <code>pathname</code> is <code>nil</code> or a <code>string</code>, return it unchanged.
</p>
<p>This only considers the <code>directory</code>, <code>name</code> and <code>type</code> components of the pathname.
This is a portable solution for representing relative pathnames,
But unless you are running on a Unix system, it is not a general solution
to representing native pathnames.
</p>
<p>An error is signaled if the argument is not <code>null</code>, a <code>string</code> or a <code>pathname</code>,
or if it is a <code>pathname</code> but some of its components are not recognized.
</p></dd></dl>
<a name="Function-uiop_002fpathname_003awilden"></a><dl>
<dt><a name="index-wilden"></a>Function: <strong>wilden</strong> <em>path</em></dt>
<dd><a name="index-uiop_002fpathname_003awilden"></a>
<p>From a pathname, return a wildcard pathname matching any file in any subdirectory of given pathname&rsquo;s directory
</p></dd></dl>
<a name="Macro-uiop_002fpathname_003awith_002denough_002dpathname"></a><dl>
<dt><a name="index-with_002denough_002dpathname"></a>Macro: <strong>with-enough-pathname</strong> <em>(pathname-var &amp;key pathname defaults) &amp;body  body</em></dt>
<dd><a name="index-uiop_002fpathname_003awith_002denough_002dpathname"></a>
<p>Shorthand syntax for <code>call-with-enough-pathname</code>
</p></dd></dl>
<a name="Macro-uiop_002fpathname_003awith_002dpathname_002ddefaults"></a><dl>
<dt><a name="index-with_002dpathname_002ddefaults"></a>Macro: <strong>with-pathname-defaults</strong> <em>(&amp;optional defaults) &amp;body  body</em></dt>
<dd><a name="index-uiop_002fpathname_003awith_002dpathname_002ddefaults"></a>
<p>Execute <code>body</code> in a context where the <code>*default-pathname-defaults*</code> is as specified,
where leaving the defaults <code>nil</code> or unspecified means a (<code>nil-pathname</code>), except
on ABCL, Genera and XCL, where it remains unchanged for it doubles as current-directory.
</p></dd></dl>
<a name="Variable-uiop_002fpathname_003a_002anil_002dpathname_002a"></a><dl>
<dt><a name="index-_002anil_002dpathname_002a"></a>Variable: <strong>*nil-pathname*</strong></dt>
<dd><a name="index-uiop_002fpathname_003a_002anil_002dpathname_002a"></a>
<p>A pathname that is as neutral as possible for use as defaults
when merging, making or parsing pathnames
</p></dd></dl>
<a name="Variable-uiop_002fpathname_003a_002aoutput_002dtranslation_002dfunction_002a"></a><dl>
<dt><a name="index-_002aoutput_002dtranslation_002dfunction_002a"></a>Variable: <strong>*output-translation-function*</strong></dt>
<dd><a name="index-uiop_002fpathname_003a_002aoutput_002dtranslation_002dfunction_002a"></a>
<p>Hook for output translations.
</p>
<p>This function needs to be idempotent, so that actions can work
whether their inputs were translated or not,
which they will be if we are composing operations. e.g. if some
create-lisp-op creates a lisp file from some higher-level input,
you need to still be able to use compile-op on that lisp file.
</p></dd></dl>
<a name="Variable-uiop_002fpathname_003a_002aunspecific_002dpathname_002dtype_002a"></a><dl>
<dt><a name="index-_002aunspecific_002dpathname_002dtype_002a"></a>Variable: <strong>*unspecific-pathname-type*</strong></dt>
<dd><a name="index-uiop_002fpathname_003a_002aunspecific_002dpathname_002dtype_002a"></a>
<p>Unspecific type component to use with the underlying implementation&rsquo;s <code>make-pathname</code>
</p></dd></dl>
<a name="Variable-uiop_002fpathname_003a_002awild_002ddirectory_002a"></a><dl>
<dt><a name="index-_002awild_002ddirectory_002a"></a>Variable: <strong>*wild-directory*</strong></dt>
<dd><a name="index-uiop_002fpathname_003a_002awild_002ddirectory_002a"></a>
<p>A pathname object with wildcards for matching any subdirectory
</p></dd></dl>
<a name="Variable-uiop_002fpathname_003a_002awild_002dfile_002dfor_002ddirectory_002a"></a><dl>
<dt><a name="index-_002awild_002dfile_002dfor_002ddirectory_002a"></a>Variable: <strong>*wild-file-for-directory*</strong></dt>
<dd><a name="index-uiop_002fpathname_003a_002awild_002dfile_002dfor_002ddirectory_002a"></a>
<p>A pathname object with wildcards for matching any file with <code>directory</code>
</p></dd></dl>
<a name="Variable-uiop_002fpathname_003a_002awild_002dfile_002a"></a><dl>
<dt><a name="index-_002awild_002dfile_002a"></a>Variable: <strong>*wild-file*</strong></dt>
<dd><a name="index-uiop_002fpathname_003a_002awild_002dfile_002a"></a>
<p>A pathname object with wildcards for matching any file with <code>translate-pathname</code>
</p></dd></dl>
<a name="Variable-uiop_002fpathname_003a_002awild_002dinferiors_002a"></a><dl>
<dt><a name="index-_002awild_002dinferiors_002a"></a>Variable: <strong>*wild-inferiors*</strong></dt>
<dd><a name="index-uiop_002fpathname_003a_002awild_002dinferiors_002a"></a>
<p>A pathname object with wildcards for matching any recursive subdirectory
</p></dd></dl>
<a name="Variable-uiop_002fpathname_003a_002awild_002dpath_002a"></a><dl>
<dt><a name="index-_002awild_002dpath_002a"></a>Variable: <strong>*wild-path*</strong></dt>
<dd><a name="index-uiop_002fpathname_003a_002awild_002dpath_002a"></a>
<p>A pathname object with wildcards for matching any file in any recursive subdirectory
</p></dd></dl>
<a name="Variable-uiop_002fpathname_003a_002awild_002a"></a><dl>
<dt><a name="index-_002awild_002a"></a>Variable: <strong>*wild*</strong></dt>
<dd><a name="index-uiop_002fpathname_003a_002awild_002a"></a>
<p>Wild component for use with <code>make-pathname</code>
</p></dd></dl>

<hr>
<a name="UIOP_002fFILESYSTEM"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fSTREAM" accesskey="n" rel="next">UIOP/STREAM</a>, Previous: <a href="#UIOP_002fPATHNAME" accesskey="p" rel="prev">UIOP/PATHNAME</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fFILESYSTEM-1"></a>
<h2 class="chapter">8 UIOP/FILESYSTEM</h2>

<a name="Function-uiop_002ffilesystem_003acall_002dwith_002dcurrent_002ddirectory"></a><dl>
<dt><a name="index-call_002dwith_002dcurrent_002ddirectory"></a>Function: <strong>call-with-current-directory</strong> <em>dir thunk</em></dt>
<dd><a name="index-uiop_002ffilesystem_003acall_002dwith_002dcurrent_002ddirectory"></a>
<p>call the <code>thunk</code> in a context where the current directory was changed to <code>dir</code>, if not <code>nil</code>.
Note that this operation is usually <code>not</code> thread-safe.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003acollect_002dsub_002adirectories"></a><dl>
<dt><a name="index-collect_002dsub_002adirectories"></a>Function: <strong>collect-sub*directories</strong> <em>directory collectp recursep collector</em></dt>
<dd><a name="index-uiop_002ffilesystem_003acollect_002dsub_002adirectories"></a>
<p>Given a <code>directory</code>, when <code>collectp</code> returns true when <code>call-function</code>&rsquo;ed with the directory,
call-function the <code>collector</code> function designator on the directory,
and recurse each of its subdirectories on which the <code>recursep</code> returns true when <code>call-function</code>&rsquo;ed with them.
This function will thus let you traverse a filesystem hierarchy,
superseding the functionality of <code>cl-fad:walk-directory</code>.
The behavior in presence of symlinks is not portable. Use IOlib to handle such situations.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003adelete_002ddirectory_002dtree"></a><dl>
<dt><a name="index-delete_002ddirectory_002dtree"></a>Function: <strong>delete-directory-tree</strong> <em>directory-pathname &amp;key  validate if-does-not-exist</em></dt>
<dd><a name="index-uiop_002ffilesystem_003adelete_002ddirectory_002dtree"></a>
<p>Delete a directory including all its recursive contents, aka rm -rf.
</p>
<p>To reduce the risk of infortunate mistakes, <code>directory-pathname</code> must be
a physical non-wildcard directory pathname (not namestring).
</p>
<p>If the directory does not exist, the <code>if-does-not-exist</code> argument specifies what happens:
if it is <code>:error</code> (the default), an error is signaled, whereas if it is <code>:ignore</code>, nothing is done.
</p>
<p>Furthermore, before any deletion is attempted, the <code>directory-pathname</code> must pass
the validation function designated (as per <code>ensure-function</code>) by the <code>validate</code> keyword argument
which in practice is thus compulsory, and validates by returning a non-NIL result.
If you&rsquo;re suicidal or extremely confident, just use <code>:validate</code> <code>t</code>.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003adelete_002dempty_002ddirectory"></a><dl>
<dt><a name="index-delete_002dempty_002ddirectory"></a>Function: <strong>delete-empty-directory</strong> <em>directory-pathname</em></dt>
<dd><a name="index-uiop_002ffilesystem_003adelete_002dempty_002ddirectory"></a>
<p>Delete an empty directory
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003adelete_002dfile_002dif_002dexists"></a><dl>
<dt><a name="index-delete_002dfile_002dif_002dexists"></a>Function: <strong>delete-file-if-exists</strong> <em>x</em></dt>
<dd><a name="index-uiop_002ffilesystem_003adelete_002dfile_002dif_002dexists"></a>
<p>Delete a file <code>x</code> if it already exists
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003adirectory_002dexists_002dp"></a><dl>
<dt><a name="index-directory_002dexists_002dp"></a>Function: <strong>directory-exists-p</strong> <em>x</em></dt>
<dd><a name="index-uiop_002ffilesystem_003adirectory_002dexists_002dp"></a>
<p>Is <code>x</code> the name of a directory that exists on the filesystem?
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003adirectory_002dfiles"></a><dl>
<dt><a name="index-directory_002dfiles"></a>Function: <strong>directory-files</strong> <em>directory &amp;optional  pattern</em></dt>
<dd><a name="index-uiop_002ffilesystem_003adirectory_002dfiles"></a>
<p>Return a list of the files in a directory according to the <code>pattern</code>.
Subdirectories should <code>not</code> be returned.
  <code>pattern</code> defaults to a pattern carefully chosen based on the implementation;
override the default at your own risk.
  <code>directory-files</code> tries <code>not</code> to resolve symlinks if the implementation permits this,
but the behavior in presence of symlinks is not portable. Use IOlib to handle such situations.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003adirectory_002a"></a><dl>
<dt><a name="index-directory_002a"></a>Function: <strong>directory*</strong> <em>pathname-spec &amp;rest  keys &amp;key  &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002ffilesystem_003adirectory_002a"></a>
<p>Return a list of the entries in a directory by calling <code>directory</code>.
Try to override the defaults to not resolving symlinks, if implementation allows.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003aensure_002dall_002ddirectories_002dexist"></a><dl>
<dt><a name="index-ensure_002dall_002ddirectories_002dexist"></a>Function: <strong>ensure-all-directories-exist</strong> <em>pathnames</em></dt>
<dd><a name="index-uiop_002ffilesystem_003aensure_002dall_002ddirectories_002dexist"></a>
<p>Ensure that for every pathname in <code>pathnames</code>, we ensure its directories exist
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003afile_002dexists_002dp"></a><dl>
<dt><a name="index-file_002dexists_002dp"></a>Function: <strong>file-exists-p</strong> <em>x</em></dt>
<dd><a name="index-uiop_002ffilesystem_003afile_002dexists_002dp"></a>
<p>Is <code>x</code> the name of a file that exists on the filesystem?
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003afilter_002dlogical_002ddirectory_002dresults"></a><dl>
<dt><a name="index-filter_002dlogical_002ddirectory_002dresults"></a>Function: <strong>filter-logical-directory-results</strong> <em>directory entries merger</em></dt>
<dd><a name="index-uiop_002ffilesystem_003afilter_002dlogical_002ddirectory_002dresults"></a>
<p>If <code>directory</code> isn&rsquo;t a logical pathname, return <code>entries</code>. If it is,
given <code>entries</code> in the <code>directory</code>, remove the entries which are physical yet
when transformed by <code>merger</code> have a different <code>truename</code>.
Also remove duplicates as may appear with some translation rules.
This function is used as a helper to <code>directory-files</code> to avoid invalid entries
when using logical-pathnames.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003aget_002dpathname_002ddefaults"></a><dl>
<dt><a name="index-get_002dpathname_002ddefaults"></a>Function: <strong>get-pathname-defaults</strong> <em>&amp;optional  defaults</em></dt>
<dd><a name="index-uiop_002ffilesystem_003aget_002dpathname_002ddefaults"></a>
<p>Find the actual <code>defaults</code> to use for pathnames, including
resolving them with respect to <code>getcwd</code> if the <code>defaults</code> were relative
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003agetenv_002dabsolute_002ddirectories"></a><dl>
<dt><a name="index-getenv_002dabsolute_002ddirectories"></a>Function: <strong>getenv-absolute-directories</strong> <em>x</em></dt>
<dd><a name="index-uiop_002ffilesystem_003agetenv_002dabsolute_002ddirectories"></a>
<p>Extract a list of absolute directories from a user-configured environment variable,
as per native OS.  Any empty entries in the environment variable <code>x</code> will be returned as
NILs.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003agetenv_002dabsolute_002ddirectory"></a><dl>
<dt><a name="index-getenv_002dabsolute_002ddirectory"></a>Function: <strong>getenv-absolute-directory</strong> <em>x</em></dt>
<dd><a name="index-uiop_002ffilesystem_003agetenv_002dabsolute_002ddirectory"></a>
<p>Extract an absolute directory pathname from a user-configured environment variable,
as per native OS
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003agetenv_002dpathname"></a><dl>
<dt><a name="index-getenv_002dpathname"></a>Function: <strong>getenv-pathname</strong> <em>x &amp;rest  constraints &amp;key  ensure-directory want-directory on-error &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002ffilesystem_003agetenv_002dpathname"></a>
<p>Extract a pathname from a user-configured environment variable, as per native OS,
check constraints and normalize as per <code>ensure-pathname</code>.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003agetenv_002dpathnames"></a><dl>
<dt><a name="index-getenv_002dpathnames"></a>Function: <strong>getenv-pathnames</strong> <em>x &amp;rest  constraints &amp;key  on-error &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002ffilesystem_003agetenv_002dpathnames"></a>
<p>Extract a list of pathname from a user-configured environment variable, as per native OS,
check constraints and normalize each one as per <code>ensure-pathname</code>.
       Any empty entries in the environment variable <code>x</code> will be returned as NILs.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003ainter_002ddirectory_002dseparator"></a><dl>
<dt><a name="index-inter_002ddirectory_002dseparator"></a>Function: <strong>inter-directory-separator</strong></dt>
<dd><a name="index-uiop_002ffilesystem_003ainter_002ddirectory_002dseparator"></a>
<p>What character does the current OS conventionally uses to separate directories?
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003alisp_002dimplementation_002ddirectory"></a><dl>
<dt><a name="index-lisp_002dimplementation_002ddirectory"></a>Function: <strong>lisp-implementation-directory</strong> <em>&amp;key  truename</em></dt>
<dd><a name="index-uiop_002ffilesystem_003alisp_002dimplementation_002ddirectory"></a>
<p>Where are the system files of the current installation of the CL implementation?
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003alisp_002dimplementation_002dpathname_002dp"></a><dl>
<dt><a name="index-lisp_002dimplementation_002dpathname_002dp"></a>Function: <strong>lisp-implementation-pathname-p</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002ffilesystem_003alisp_002dimplementation_002dpathname_002dp"></a>
<p>Is the <code>pathname</code> under the current installation of the CL implementation?
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003anative_002dnamestring"></a><dl>
<dt><a name="index-native_002dnamestring"></a>Function: <strong>native-namestring</strong> <em>x</em></dt>
<dd><a name="index-uiop_002ffilesystem_003anative_002dnamestring"></a>
<p>From a non-wildcard CL pathname, a return namestring suitable for passing to the operating system
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003aparse_002dnative_002dnamestring"></a><dl>
<dt><a name="index-parse_002dnative_002dnamestring"></a>Function: <strong>parse-native-namestring</strong> <em>string &amp;rest  constraints &amp;key  ensure-directory &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002ffilesystem_003aparse_002dnative_002dnamestring"></a>
<p>From a native namestring suitable for use by the operating system, return
a CL pathname satisfying all the specified constraints as per <code>ensure-pathname</code>
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003aprobe_002dfile_002a"></a><dl>
<dt><a name="index-probe_002dfile_002a"></a>Function: <strong>probe-file*</strong> <em>p &amp;key  truename</em></dt>
<dd><a name="index-uiop_002ffilesystem_003aprobe_002dfile_002a"></a>
<p>when given a pathname <code>p</code> (designated by a string as per <code>parse-namestring</code>),
probes the filesystem for a file or directory with given pathname.
If it exists, return its truename if <code>truename</code> is true,
or the original (parsed) pathname if it is false (the default).
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003arename_002dfile_002doverwriting_002dtarget"></a><dl>
<dt><a name="index-rename_002dfile_002doverwriting_002dtarget"></a>Function: <strong>rename-file-overwriting-target</strong> <em>source target</em></dt>
<dd><a name="index-uiop_002ffilesystem_003arename_002dfile_002doverwriting_002dtarget"></a>
<p>Rename a file, overwriting any previous file with the <code>target</code> name,
in an atomic way if the implementation allows.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003aresolve_002dsymlinks_002a"></a><dl>
<dt><a name="index-resolve_002dsymlinks_002a"></a>Function: <strong>resolve-symlinks*</strong> <em>path</em></dt>
<dd><a name="index-uiop_002ffilesystem_003aresolve_002dsymlinks_002a"></a>
<p><code>resolve-symlinks</code> in <code>path</code> iff <code>*resolve-symlinks*</code> is <code>t</code> (the default).
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003aresolve_002dsymlinks"></a><dl>
<dt><a name="index-resolve_002dsymlinks"></a>Function: <strong>resolve-symlinks</strong> <em>path</em></dt>
<dd><a name="index-uiop_002ffilesystem_003aresolve_002dsymlinks"></a>
<p>Do a best effort at resolving symlinks in <code>path</code>, returning a partially or totally resolved <code>path</code>.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003asafe_002dfile_002dwrite_002ddate"></a><dl>
<dt><a name="index-safe_002dfile_002dwrite_002ddate"></a>Function: <strong>safe-file-write-date</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002ffilesystem_003asafe_002dfile_002dwrite_002ddate"></a>
<p>Safe variant of <code>file-write-date</code> that may return <code>nil</code> rather than raise an error.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003asplit_002dnative_002dpathnames_002dstring"></a><dl>
<dt><a name="index-split_002dnative_002dpathnames_002dstring"></a>Function: <strong>split-native-pathnames-string</strong> <em>string &amp;rest  constraints &amp;key  &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002ffilesystem_003asplit_002dnative_002dpathnames_002dstring"></a>
<p>Given a string of pathnames specified in native OS syntax, separate them in a list,
check constraints and normalize each one as per <code>ensure-pathname</code>,
where an empty string denotes <code>nil</code>.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003asubdirectories"></a><dl>
<dt><a name="index-subdirectories"></a>Function: <strong>subdirectories</strong> <em>directory</em></dt>
<dd><a name="index-uiop_002ffilesystem_003asubdirectories"></a>
<p>Given a <code>directory</code> pathname designator, return a list of the subdirectories under it.
The behavior in presence of symlinks is not portable. Use IOlib to handle such situations.
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003atruename_002a"></a><dl>
<dt><a name="index-truename_002a"></a>Function: <strong>truename*</strong> <em>p</em></dt>
<dd><a name="index-uiop_002ffilesystem_003atruename_002a"></a>
<p>Nicer variant of <code>truename</code> that plays well with <code>nil</code>, avoids logical pathname contexts, and tries both files and directories
</p></dd></dl>
<a name="Function-uiop_002ffilesystem_003atruenamize"></a><dl>
<dt><a name="index-truenamize"></a>Function: <strong>truenamize</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002ffilesystem_003atruenamize"></a>
<p>Resolve as much of a pathname as possible
</p></dd></dl>
<a name="Macro-uiop_002ffilesystem_003awith_002dcurrent_002ddirectory"></a><dl>
<dt><a name="index-with_002dcurrent_002ddirectory"></a>Macro: <strong>with-current-directory</strong> <em>(&amp;optional dir) &amp;body  body</em></dt>
<dd><a name="index-uiop_002ffilesystem_003awith_002dcurrent_002ddirectory"></a>
<p>Call <code>body</code> while the POSIX current working directory is set to <code>dir</code>
</p></dd></dl>
<a name="Variable-uiop_002ffilesystem_003a_002aresolve_002dsymlinks_002a"></a><dl>
<dt><a name="index-_002aresolve_002dsymlinks_002a"></a>Variable: <strong>*resolve-symlinks*</strong></dt>
<dd><a name="index-uiop_002ffilesystem_003a_002aresolve_002dsymlinks_002a"></a>
<p>Determine whether or not ASDF resolves symlinks when defining systems.
Defaults to <code>t</code>.
</p></dd></dl>

<hr>
<a name="UIOP_002fSTREAM"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fIMAGE" accesskey="n" rel="next">UIOP/IMAGE</a>, Previous: <a href="#UIOP_002fFILESYSTEM" accesskey="p" rel="prev">UIOP/FILESYSTEM</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fSTREAM-1"></a>
<h2 class="chapter">9 UIOP/STREAM</h2>

<a name="Function-uiop_002fstream_003aadd_002dpathname_002dsuffix"></a><dl>
<dt><a name="index-add_002dpathname_002dsuffix"></a>Function: <strong>add-pathname-suffix</strong> <em>pathname suffix &amp;rest  keys</em></dt>
<dd><a name="index-uiop_002fstream_003aadd_002dpathname_002dsuffix"></a>
<p>Add a <code>suffix</code> to the name of a <code>pathname</code>, return a new pathname.
Further <code>keys</code> can be passed to <code>make-pathname</code>.
</p></dd></dl>
<a name="Function-uiop_002fstream_003aalways_002ddefault_002dencoding"></a><dl>
<dt><a name="index-always_002ddefault_002dencoding"></a>Function: <strong>always-default-encoding</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002fstream_003aalways_002ddefault_002dencoding"></a>
<p>Trivial function to use as *encoding-detection-hook*,
always &rsquo;detects&rsquo; the *default-encoding*
</p></dd></dl>
<a name="Function-uiop_002fstream_003acall_002dwith_002dinput_002dfile"></a><dl>
<dt><a name="index-call_002dwith_002dinput_002dfile"></a>Function: <strong>call-with-input-file</strong> <em>pathname thunk &amp;key  element-type external-format if-does-not-exist</em></dt>
<dd><a name="index-uiop_002fstream_003acall_002dwith_002dinput_002dfile"></a>
<p>Open <code>file</code> for input with given recognizes options, call <code>thunk</code> with the resulting stream.
Other keys are accepted but discarded.
</p></dd></dl>
<a name="Function-uiop_002fstream_003acall_002dwith_002dnull_002dinput"></a><dl>
<dt><a name="index-call_002dwith_002dnull_002dinput"></a>Function: <strong>call-with-null-input</strong> <em>fun &amp;rest  keys &amp;key  element-type external-format if-does-not-exist</em></dt>
<dd><a name="index-uiop_002fstream_003acall_002dwith_002dnull_002dinput"></a>
<p>Call <code>fun</code> with an input stream from the null device; pass keyword arguments to <code>open</code>.
</p></dd></dl>
<a name="Function-uiop_002fstream_003acall_002dwith_002dnull_002doutput"></a><dl>
<dt><a name="index-call_002dwith_002dnull_002doutput"></a>Function: <strong>call-with-null-output</strong> <em>fun &amp;key  element-type external-format if-exists if-does-not-exist</em></dt>
<dd><a name="index-uiop_002fstream_003acall_002dwith_002dnull_002doutput"></a>
<p>Call <code>fun</code> with an output stream to the null device; pass keyword arguments to <code>open</code>.
</p></dd></dl>
<a name="Function-uiop_002fstream_003acall_002dwith_002doutput_002dfile"></a><dl>
<dt><a name="index-call_002dwith_002doutput_002dfile"></a>Function: <strong>call-with-output-file</strong> <em>pathname thunk &amp;key  element-type external-format if-exists if-does-not-exist</em></dt>
<dd><a name="index-uiop_002fstream_003acall_002dwith_002doutput_002dfile"></a>
<p>Open <code>file</code> for input with given recognizes options, call <code>thunk</code> with the resulting stream.
Other keys are accepted but discarded.
</p></dd></dl>
<a name="Function-uiop_002fstream_003acall_002dwith_002dstaging_002dpathname"></a><dl>
<dt><a name="index-call_002dwith_002dstaging_002dpathname"></a>Function: <strong>call-with-staging-pathname</strong> <em>pathname fun</em></dt>
<dd><a name="index-uiop_002fstream_003acall_002dwith_002dstaging_002dpathname"></a>
<p>Calls <code>fun</code> with a staging pathname, and atomically
renames the staging pathname to the <code>pathname</code> in the end.
<code>nb:</code> this protects only against failure of the program, not against concurrent attempts.
For the latter case, we ought pick a random suffix and atomically open it.
</p></dd></dl>
<a name="Function-uiop_002fstream_003acall_002dwith_002dtemporary_002dfile"></a><dl>
<dt><a name="index-call_002dwith_002dtemporary_002dfile"></a>Function: <strong>call-with-temporary-file</strong> <em>thunk &amp;key  want-stream-p want-pathname-p direction keep after directory type prefix suffix element-type external-format</em></dt>
<dd><a name="index-uiop_002fstream_003acall_002dwith_002dtemporary_002dfile"></a>
<p>Call a <code>thunk</code> with stream and/or pathname arguments identifying a temporary file.
</p>
<p>The temporary file&rsquo;s pathname will be based on concatenating
<code>prefix</code> (or &quot;tmp&quot; if it&rsquo;s <code>nil</code>), a random alphanumeric string,
and optional <code>suffix</code> (defaults to &quot;-tmp&quot; if a type was provided)
and <code>type</code> (defaults to &quot;tmp&quot;, using a dot as separator if not <code>nil</code>),
within <code>directory</code> (defaulting to the <code>temporary-directory</code>) if the <code>prefix</code> isn&rsquo;t absolute.
</p>
<p>The file will be open with specified <code>direction</code> (defaults to <code>:io</code>),
<code>element-type</code> (defaults to <code>*default-stream-element-type*</code>) and
<code>external-format</code> (defaults to <code>*utf-8-external-format*</code>).
If <code>want-stream-p</code> is true (the defaults to <code>t</code>), then <code>thunk</code> will then be <code>call-function</code>&rsquo;ed
with the stream and the pathname (if <code>want-pathname-p</code> is true, defaults to <code>t</code>),
and stream will be closed after the <code>thunk</code> exits (either normally or abnormally).
If <code>want-stream-p</code> is false, then <code>want-pathame-p</code> must be true, and then
<code>thunk</code> is only <code>call-function</code>&rsquo;ed after the stream is closed, with the pathname as argument.
Upon exit of <code>thunk</code>, the <code>after</code> thunk if defined is <code>call-function</code>&rsquo;ed with the pathname as argument.
If <code>after</code> is defined, its results are returned, otherwise, the results of <code>thunk</code> are returned.
Finally, the file will be deleted, unless the <code>keep</code> argument when <code>call-function</code>&rsquo;ed returns true.
</p></dd></dl>
<a name="Function-uiop_002fstream_003aconcatenate_002dfiles"></a><dl>
<dt><a name="index-concatenate_002dfiles"></a>Function: <strong>concatenate-files</strong> <em>inputs output</em></dt>
<dd><a name="index-uiop_002fstream_003aconcatenate_002dfiles"></a>
<p>create a new <code>output</code> file the contents of which a the concatenate of the <code>inputs</code> files.
</p></dd></dl>
<a name="Function-uiop_002fstream_003acopy_002dfile"></a><dl>
<dt><a name="index-copy_002dfile"></a>Function: <strong>copy-file</strong> <em>input output</em></dt>
<dd><a name="index-uiop_002fstream_003acopy_002dfile"></a>
<p>Copy contents of the <code>input</code> file to the <code>output</code> file
</p></dd></dl>
<a name="Function-uiop_002fstream_003acopy_002dstream_002dto_002dstream"></a><dl>
<dt><a name="index-copy_002dstream_002dto_002dstream"></a>Function: <strong>copy-stream-to-stream</strong> <em>input output &amp;key  element-type buffer-size linewise prefix</em></dt>
<dd><a name="index-uiop_002fstream_003acopy_002dstream_002dto_002dstream"></a>
<p>Copy the contents of the <code>input</code> stream into the <code>output</code> stream.
If <code>linewise</code> is true, then read and copy the stream line by line, with an optional <code>prefix</code>.
Otherwise, using <code>write-sequence</code> using a buffer of size <code>buffer-size</code>.
</p></dd></dl>
<a name="Function-uiop_002fstream_003adefault_002dencoding_002dexternal_002dformat"></a><dl>
<dt><a name="index-default_002dencoding_002dexternal_002dformat"></a>Function: <strong>default-encoding-external-format</strong> <em>encoding</em></dt>
<dd><a name="index-uiop_002fstream_003adefault_002dencoding_002dexternal_002dformat"></a>
<p>Default, ignorant, function to transform a character <code>encoding</code> as a
portable keyword to an implementation-dependent <code>external-format</code> specification.
Load system <code>asdf-encodings</code> to hook in a better one.
</p></dd></dl>
<a name="Function-uiop_002fstream_003adefault_002dtemporary_002ddirectory"></a><dl>
<dt><a name="index-default_002dtemporary_002ddirectory"></a>Function: <strong>default-temporary-directory</strong></dt>
<dd><a name="index-uiop_002fstream_003adefault_002dtemporary_002ddirectory"></a>
<p>Return a default directory to use for temporary files
</p></dd></dl>
<a name="Function-uiop_002fstream_003adetect_002dencoding"></a><dl>
<dt><a name="index-detect_002dencoding"></a>Function: <strong>detect-encoding</strong> <em>pathname</em></dt>
<dd><a name="index-uiop_002fstream_003adetect_002dencoding"></a>
<p>Detects the encoding of a specified file, going through user-configurable hooks
</p></dd></dl>
<a name="Function-uiop_002fstream_003aencoding_002dexternal_002dformat"></a><dl>
<dt><a name="index-encoding_002dexternal_002dformat"></a>Function: <strong>encoding-external-format</strong> <em>encoding</em></dt>
<dd><a name="index-uiop_002fstream_003aencoding_002dexternal_002dformat"></a>
<p>Transform a portable <code>encoding</code> keyword to an implementation-dependent <code>external-format</code>,
going through all the proper hooks.
</p></dd></dl>
<a name="Function-uiop_002fstream_003aeval_002dinput"></a><dl>
<dt><a name="index-eval_002dinput"></a>Function: <strong>eval-input</strong> <em>input</em></dt>
<dd><a name="index-uiop_002fstream_003aeval_002dinput"></a>
<p>Portably read and evaluate forms from <code>input</code>, return the last values.
</p></dd></dl>
<a name="Function-uiop_002fstream_003aeval_002dthunk"></a><dl>
<dt><a name="index-eval_002dthunk"></a>Function: <strong>eval-thunk</strong> <em>thunk</em></dt>
<dd><a name="index-uiop_002fstream_003aeval_002dthunk"></a>
<p>Evaluate a <code>thunk</code> of code:
If a function, <code>funcall</code> it without arguments.
If a constant literal and not a sequence, return it.
If a cons or a symbol, <code>eval</code> it.
If a string, repeatedly read and evaluate from it, returning the last values.
</p></dd></dl>
<a name="Function-uiop_002fstream_003afinish_002doutputs"></a><dl>
<dt><a name="index-finish_002doutputs"></a>Function: <strong>finish-outputs</strong> <em>&amp;rest  streams</em></dt>
<dd><a name="index-uiop_002fstream_003afinish_002doutputs"></a>
<p>Finish output on the main output streams as well as any specified one.
Useful for portably flushing I/O before user input or program exit.
</p></dd></dl>
<a name="Function-uiop_002fstream_003aformat_0021"></a><dl>
<dt><a name="index-format_0021"></a>Function: <strong>format!</strong> <em>stream format &amp;rest  args</em></dt>
<dd><a name="index-uiop_002fstream_003aformat_0021"></a>
<p>Just like format, but call finish-outputs before and after the output.
</p></dd></dl>
<a name="Function-uiop_002fstream_003ainput_002dstring"></a><dl>
<dt><a name="index-input_002dstring"></a>Function: <strong>input-string</strong> <em>&amp;optional  input</em></dt>
<dd><a name="index-uiop_002fstream_003ainput_002dstring"></a>
<p>If the desired <code>input</code> is a string, return that string; otherwise slurp the <code>input</code> into a string
and return that
</p></dd></dl>
<a name="Function-uiop_002fstream_003anull_002ddevice_002dpathname"></a><dl>
<dt><a name="index-null_002ddevice_002dpathname"></a>Function: <strong>null-device-pathname</strong></dt>
<dd><a name="index-uiop_002fstream_003anull_002ddevice_002dpathname"></a>
<p>Pathname to a bit bucket device that discards any information written to it
and always returns <code>eof</code> when read from
</p></dd></dl>
<a name="Function-uiop_002fstream_003aoutput_002dstring"></a><dl>
<dt><a name="index-output_002dstring"></a>Function: <strong>output-string</strong> <em>string &amp;optional  output</em></dt>
<dd><a name="index-uiop_002fstream_003aoutput_002dstring"></a>
<p>If the desired <code>output</code> is not <code>nil</code>, print the string to the output; otherwise return the string
</p></dd></dl>
<a name="Function-uiop_002fstream_003aprintln"></a><dl>
<dt><a name="index-println"></a>Function: <strong>println</strong> <em>x &amp;optional  stream</em></dt>
<dd><a name="index-uiop_002fstream_003aprintln"></a>
<p>Variant of <code>princ</code> that also calls <code>terpri</code> afterwards
</p></dd></dl>
<a name="Function-uiop_002fstream_003aread_002dfile_002dform"></a><dl>
<dt><a name="index-read_002dfile_002dform"></a>Function: <strong>read-file-form</strong> <em>file &amp;rest  keys &amp;key  at &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002fstream_003aread_002dfile_002dform"></a>
<p>Open input <code>file</code> with option <code>keys</code> (except <code>at</code>),
and read its contents as per <code>slurp-stream-form</code> with given <code>at</code> specifier.
<code>beware:</code> be sure to use <code>with-safe-io-syntax</code>, or some variant thereof
</p></dd></dl>
<a name="Function-uiop_002fstream_003aread_002dfile_002dforms"></a><dl>
<dt><a name="index-read_002dfile_002dforms"></a>Function: <strong>read-file-forms</strong> <em>file &amp;rest  keys &amp;key  count &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002fstream_003aread_002dfile_002dforms"></a>
<p>Open input <code>file</code> with option <code>keys</code> (except <code>count</code>),
and read its contents as per <code>slurp-stream-forms</code> with given <code>count</code>.
<code>beware:</code> be sure to use <code>with-safe-io-syntax</code>, or some variant thereof
</p></dd></dl>
<a name="Function-uiop_002fstream_003aread_002dfile_002dline"></a><dl>
<dt><a name="index-read_002dfile_002dline"></a>Function: <strong>read-file-line</strong> <em>file &amp;rest  keys &amp;key  at &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002fstream_003aread_002dfile_002dline"></a>
<p>Open input <code>file</code> with option <code>keys</code> (except <code>at</code>),
and read its contents as per <code>slurp-stream-line</code> with given <code>at</code> specifier.
<code>beware:</code> be sure to use <code>with-safe-io-syntax</code>, or some variant thereof
</p></dd></dl>
<a name="Function-uiop_002fstream_003aread_002dfile_002dlines"></a><dl>
<dt><a name="index-read_002dfile_002dlines"></a>Function: <strong>read-file-lines</strong> <em>file &amp;rest  keys</em></dt>
<dd><a name="index-uiop_002fstream_003aread_002dfile_002dlines"></a>
<p>Open <code>file</code> with option <code>keys</code>, read its contents as a list of lines
<code>beware:</code> be sure to use <code>with-safe-io-syntax</code>, or some variant thereof
</p></dd></dl>
<a name="Function-uiop_002fstream_003aread_002dfile_002dstring"></a><dl>
<dt><a name="index-read_002dfile_002dstring"></a>Function: <strong>read-file-string</strong> <em>file &amp;rest  keys</em></dt>
<dd><a name="index-uiop_002fstream_003aread_002dfile_002dstring"></a>
<p>Open <code>file</code> with option <code>keys</code>, read its contents as a string
</p></dd></dl>
<a name="Function-uiop_002fstream_003asafe_002dformat_0021"></a><dl>
<dt><a name="index-safe_002dformat_0021"></a>Function: <strong>safe-format!</strong> <em>stream format &amp;rest  args</em></dt>
<dd><a name="index-uiop_002fstream_003asafe_002dformat_0021"></a>
<p>Variant of <code>format</code> that is safe against both
dangerous syntax configuration and errors while printing.
</p></dd></dl>
<a name="Function-uiop_002fstream_003asafe_002dread_002dfile_002dform"></a><dl>
<dt><a name="index-safe_002dread_002dfile_002dform"></a>Function: <strong>safe-read-file-form</strong> <em>pathname &amp;rest  keys &amp;key  package &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002fstream_003asafe_002dread_002dfile_002dform"></a>
<p>Reads the specified form from the top of a file using a safe standardized syntax.
Extracts the form using <code>read-file-form</code>,
within an <code>with-safe-io-syntax</code> using the specified <code>package</code>.
</p></dd></dl>
<a name="Function-uiop_002fstream_003asafe_002dread_002dfile_002dline"></a><dl>
<dt><a name="index-safe_002dread_002dfile_002dline"></a>Function: <strong>safe-read-file-line</strong> <em>pathname &amp;rest  keys &amp;key  package &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002fstream_003asafe_002dread_002dfile_002dline"></a>
<p>Reads the specified line from the top of a file using a safe standardized syntax.
Extracts the line using <code>read-file-line</code>,
within an <code>with-safe-io-syntax</code> using the specified <code>package</code>.
</p></dd></dl>
<a name="Function-uiop_002fstream_003asafe_002dread_002dfrom_002dstring"></a><dl>
<dt><a name="index-safe_002dread_002dfrom_002dstring"></a>Function: <strong>safe-read-from-string</strong> <em>string &amp;key  package eof-error-p eof-value start end preserve-whitespace</em></dt>
<dd><a name="index-uiop_002fstream_003asafe_002dread_002dfrom_002dstring"></a>
<p>Read from <code>string</code> using a safe syntax, as per <code>with-safe-io-syntax</code>
</p></dd></dl>
<a name="Function-uiop_002fstream_003asetup_002dtemporary_002ddirectory"></a><dl>
<dt><a name="index-setup_002dtemporary_002ddirectory"></a>Function: <strong>setup-temporary-directory</strong></dt>
<dd><a name="index-uiop_002fstream_003asetup_002dtemporary_002ddirectory"></a>
<p>Configure a default temporary directory to use.
</p></dd></dl>
<a name="Function-uiop_002fstream_003aslurp_002dstream_002dform"></a><dl>
<dt><a name="index-slurp_002dstream_002dform"></a>Function: <strong>slurp-stream-form</strong> <em>input &amp;key  at</em></dt>
<dd><a name="index-uiop_002fstream_003aslurp_002dstream_002dform"></a>
<p>Read the contents of the <code>input</code> stream as a list of forms,
then return the <code>access-at</code> of these forms following the <code>at</code>.
<code>at</code> defaults to <code>0</code>, i.e. return the first form.
<code>at</code> is typically a list of integers.
If <code>at</code> is <code>nil</code>, it will return all the forms in the file.
</p>
<p>The stream will not be read beyond the Nth form,
where <code>n</code> is the index specified by path,
if path is either an integer or a list that starts with an integer.
</p>
<p><code>beware:</code> be sure to use <code>with-safe-io-syntax</code>, or some variant thereof
</p></dd></dl>
<a name="Function-uiop_002fstream_003aslurp_002dstream_002dforms"></a><dl>
<dt><a name="index-slurp_002dstream_002dforms"></a>Function: <strong>slurp-stream-forms</strong> <em>input &amp;key  count</em></dt>
<dd><a name="index-uiop_002fstream_003aslurp_002dstream_002dforms"></a>
<p>Read the contents of the <code>input</code> stream as a list of forms,
and return those forms.
</p>
<p>If <code>count</code> is null, read to the end of the stream;
if <code>count</code> is an integer, stop after <code>count</code> forms were read.
</p>
<p><code>beware:</code> be sure to use <code>with-safe-io-syntax</code>, or some variant thereof
</p></dd></dl>
<a name="Function-uiop_002fstream_003aslurp_002dstream_002dline"></a><dl>
<dt><a name="index-slurp_002dstream_002dline"></a>Function: <strong>slurp-stream-line</strong> <em>input &amp;key  at</em></dt>
<dd><a name="index-uiop_002fstream_003aslurp_002dstream_002dline"></a>
<p>Read the contents of the <code>input</code> stream as a list of lines,
then return the <code>access-at</code> of that list of lines using the <code>at</code> specifier.
<code>path</code> defaults to <code>0</code>, i.e. return the first line.
<code>path</code> is typically an integer, or a list of an integer and a function.
If <code>path</code> is <code>nil</code>, it will return all the lines in the file.
</p>
<p>The stream will not be read beyond the Nth lines,
where <code>n</code> is the index specified by path
if path is either an integer or a list that starts with an integer.
</p></dd></dl>
<a name="Function-uiop_002fstream_003aslurp_002dstream_002dlines"></a><dl>
<dt><a name="index-slurp_002dstream_002dlines"></a>Function: <strong>slurp-stream-lines</strong> <em>input &amp;key  count</em></dt>
<dd><a name="index-uiop_002fstream_003aslurp_002dstream_002dlines"></a>
<p>Read the contents of the <code>input</code> stream as a list of lines, return those lines.
</p>
<p>Note: relies on the Lisp&rsquo;s <code>read-line</code>, but additionally removes any remaining CR
from the line-ending if the file or stream had CR+LF but Lisp only removed LF.
</p>
<p>Read no more than <code>count</code> lines.
</p></dd></dl>
<a name="Function-uiop_002fstream_003aslurp_002dstream_002dstring"></a><dl>
<dt><a name="index-slurp_002dstream_002dstring"></a>Function: <strong>slurp-stream-string</strong> <em>input &amp;key  element-type stripped</em></dt>
<dd><a name="index-uiop_002fstream_003aslurp_002dstream_002dstring"></a>
<p>Read the contents of the <code>input</code> stream as a string
</p></dd></dl>
<a name="Function-uiop_002fstream_003astandard_002deval_002dthunk"></a><dl>
<dt><a name="index-standard_002deval_002dthunk"></a>Function: <strong>standard-eval-thunk</strong> <em>thunk &amp;key  package</em></dt>
<dd><a name="index-uiop_002fstream_003astandard_002deval_002dthunk"></a>
<p>Like <code>eval-thunk</code>, but in a more standardized evaluation context.
</p></dd></dl>
<a name="Function-uiop_002fstream_003atemporary_002ddirectory"></a><dl>
<dt><a name="index-temporary_002ddirectory"></a>Function: <strong>temporary-directory</strong></dt>
<dd><a name="index-uiop_002fstream_003atemporary_002ddirectory"></a>
<p>Return a directory to use for temporary files
</p></dd></dl>
<a name="Function-uiop_002fstream_003atmpize_002dpathname"></a><dl>
<dt><a name="index-tmpize_002dpathname"></a>Function: <strong>tmpize-pathname</strong> <em>x</em></dt>
<dd><a name="index-uiop_002fstream_003atmpize_002dpathname"></a>
<p>Return a new pathname modified from <code>x</code> by adding a trivial random suffix.
A new empty file with said temporary pathname is created, to ensure there is no
clash with any concurrent process attempting the same thing.
</p></dd></dl>
<a name="Function-uiop_002fstream_003awriteln"></a><dl>
<dt><a name="index-writeln"></a>Function: <strong>writeln</strong> <em>x &amp;rest  keys &amp;key  stream &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002fstream_003awriteln"></a>
<p>Variant of <code>write</code> that also calls <code>terpri</code> afterwards
</p></dd></dl>
<a name="Macro-uiop_002fstream_003awith_002dinput"></a><dl>
<dt><a name="index-with_002dinput"></a>Macro: <strong>with-input</strong> <em>(input-var &amp;optional value) &amp;body  body</em></dt>
<dd><a name="index-uiop_002fstream_003awith_002dinput"></a>
<p>Bind <code>input-var</code> to an input stream, coercing <code>value</code> (default: previous binding of <code>input-var</code>)
as per <code>call-with-input</code>, and evaluate <code>body</code> within the scope of this binding.
</p></dd></dl>
<a name="Macro-uiop_002fstream_003awith_002dnull_002dinput"></a><dl>
<dt><a name="index-with_002dnull_002dinput"></a>Macro: <strong>with-null-input</strong> <em>(var &amp;rest keys &amp;key element-type external-format if-does-not-exist) &amp;body  body</em></dt>
<dd><a name="index-uiop_002fstream_003awith_002dnull_002dinput"></a>
<p>Evaluate <code>body</code> in a context when <code>var</code> is bound to an input stream accessing the null device.
Pass keyword arguments to <code>open</code>.
</p></dd></dl>
<a name="Macro-uiop_002fstream_003awith_002dnull_002doutput"></a><dl>
<dt><a name="index-with_002dnull_002doutput"></a>Macro: <strong>with-null-output</strong> <em>(var &amp;rest keys &amp;key element-type external-format if-does-not-exist if-exists) &amp;body  body</em></dt>
<dd><a name="index-uiop_002fstream_003awith_002dnull_002doutput"></a>
<p>Evaluate <code>body</code> in a context when <code>var</code> is bound to an output stream accessing the null device.
Pass keyword arguments to <code>open</code>.
</p></dd></dl>
<a name="Macro-uiop_002fstream_003awith_002doutput"></a><dl>
<dt><a name="index-with_002doutput"></a>Macro: <strong>with-output</strong> <em>(output-var &amp;optional value) &amp;body  body</em></dt>
<dd><a name="index-uiop_002fstream_003awith_002doutput"></a>
<p>Bind <code>output-var</code> to an output stream, coercing <code>value</code> (default: previous binding of <code>output-var</code>)
as per <code>format</code>, and evaluate <code>body</code> within the scope of this binding.
</p></dd></dl>
<a name="Macro-uiop_002fstream_003awith_002dsafe_002dio_002dsyntax"></a><dl>
<dt><a name="index-with_002dsafe_002dio_002dsyntax"></a>Macro: <strong>with-safe-io-syntax</strong> <em>(&amp;key package) &amp;body  body</em></dt>
<dd><a name="index-uiop_002fstream_003awith_002dsafe_002dio_002dsyntax"></a>
<p>Establish safe CL reader options around the evaluation of <code>body</code>
</p></dd></dl>
<a name="Macro-uiop_002fstream_003awith_002dstaging_002dpathname"></a><dl>
<dt><a name="index-with_002dstaging_002dpathname"></a>Macro: <strong>with-staging-pathname</strong> <em>(pathname-var &amp;optional pathname-value) &amp;body  body</em></dt>
<dd><a name="index-uiop_002fstream_003awith_002dstaging_002dpathname"></a>
<p>Trivial syntax wrapper for <code>call-with-staging-pathname</code>
</p></dd></dl>
<a name="Macro-uiop_002fstream_003awith_002dtemporary_002dfile"></a><dl>
<dt><a name="index-with_002dtemporary_002dfile"></a>Macro: <strong>with-temporary-file</strong> <em>(&amp;key stream pathname directory prefix suffix type keep direction element-type external-format) &amp;body  body</em></dt>
<dd><a name="index-uiop_002fstream_003awith_002dtemporary_002dfile"></a>
<p>Evaluate <code>body</code> where the symbols specified by keyword arguments
<code>stream</code> and <code>pathname</code> (if respectively specified) are bound corresponding
to a newly created temporary file ready for I/O, as per <code>call-with-temporary-file</code>.
At least one of <code>stream</code> or <code>pathname</code> must be specified.
If the <code>stream</code> is not specified, it will be closed before the <code>body</code> is evaluated.
If <code>stream</code> is specified, then the <code>:close-stream</code> label if it appears in the <code>body</code>,
separates forms run before and after the stream is closed.
The values of the last form of the <code>body</code> (not counting the separating <code>:close-stream</code>) are returned.
Upon success, the <code>keep</code> form is evaluated and the file is is deleted unless it evaluates to <code>true</code>.
</p></dd></dl>
<a name="Variable-uiop_002fstream_003a_002adefault_002dencoding_002a"></a><dl>
<dt><a name="index-_002adefault_002dencoding_002a"></a>Variable: <strong>*default-encoding*</strong></dt>
<dd><a name="index-uiop_002fstream_003a_002adefault_002dencoding_002a"></a>
<p>Default encoding for source files.
The default value :utf-8 is the portable thing.
The legacy behavior was :default.
If you (asdf:load-system :asdf-encodings) then
you will have autodetection via *encoding-detection-hook* below,
reading emacs-style <code>-*-</code> coding: utf-8 <code>-*-</code> specifications,
and falling back to utf-8 or latin1 if nothing is specified.
</p></dd></dl>
<a name="Variable-uiop_002fstream_003a_002adefault_002dstream_002delement_002dtype_002a"></a><dl>
<dt><a name="index-_002adefault_002dstream_002delement_002dtype_002a"></a>Variable: <strong>*default-stream-element-type*</strong></dt>
<dd><a name="index-uiop_002fstream_003a_002adefault_002dstream_002delement_002dtype_002a"></a>
<p>default element-type for open (depends on the current CL implementation)
</p></dd></dl>
<a name="Variable-uiop_002fstream_003a_002aencoding_002ddetection_002dhook_002a"></a><dl>
<dt><a name="index-_002aencoding_002ddetection_002dhook_002a"></a>Variable: <strong>*encoding-detection-hook*</strong></dt>
<dd><a name="index-uiop_002fstream_003a_002aencoding_002ddetection_002dhook_002a"></a>
<p>Hook for an extension to define a function to automatically detect a file&rsquo;s encoding
</p></dd></dl>
<a name="Variable-uiop_002fstream_003a_002aencoding_002dexternal_002dformat_002dhook_002a"></a><dl>
<dt><a name="index-_002aencoding_002dexternal_002dformat_002dhook_002a"></a>Variable: <strong>*encoding-external-format-hook*</strong></dt>
<dd><a name="index-uiop_002fstream_003a_002aencoding_002dexternal_002dformat_002dhook_002a"></a>
<p>Hook for an extension (e.g. <code>asdf-encodings</code>) to define a better mapping
from non-default encodings to and implementation-defined external-format&rsquo;s
</p></dd></dl>
<a name="Variable-uiop_002fstream_003a_002astderr_002a"></a><dl>
<dt><a name="index-_002astderr_002a"></a>Variable: <strong>*stderr*</strong></dt>
<dd><a name="index-uiop_002fstream_003a_002astderr_002a"></a>
<p>the original error output stream at startup
</p></dd></dl>
<a name="Variable-uiop_002fstream_003a_002astdin_002a"></a><dl>
<dt><a name="index-_002astdin_002a"></a>Variable: <strong>*stdin*</strong></dt>
<dd><a name="index-uiop_002fstream_003a_002astdin_002a"></a>
<p>the original standard input stream at startup
</p></dd></dl>
<a name="Variable-uiop_002fstream_003a_002astdout_002a"></a><dl>
<dt><a name="index-_002astdout_002a"></a>Variable: <strong>*stdout*</strong></dt>
<dd><a name="index-uiop_002fstream_003a_002astdout_002a"></a>
<p>the original standard output stream at startup
</p></dd></dl>
<a name="Variable-uiop_002fstream_003a_002atemporary_002ddirectory_002a"></a><dl>
<dt><a name="index-_002atemporary_002ddirectory_002a"></a>Variable: <strong>*temporary-directory*</strong></dt>
<dd><a name="index-uiop_002fstream_003a_002atemporary_002ddirectory_002a"></a>
<p>User-configurable location for temporary files
</p></dd></dl>
<a name="Variable-uiop_002fstream_003a_002autf_002d8_002dexternal_002dformat_002a"></a><dl>
<dt><a name="index-_002autf_002d8_002dexternal_002dformat_002a"></a>Variable: <strong>*utf-8-external-format*</strong></dt>
<dd><a name="index-uiop_002fstream_003a_002autf_002d8_002dexternal_002dformat_002a"></a>
<p>Default :external-format argument to pass to <code>cl:open</code> and also
<code>cl:load</code> or <code>cl:compile-file</code> to best process a <code>utf-8</code> encoded file.
On modern implementations, this will decode <code>utf-8</code> code points as CL characters.
On legacy implementations, it may fall back on some 8-bit encoding,
with non-ASCII code points being read as several CL characters;
hopefully, if done consistently, that won&rsquo;t affect program behavior too much.
</p></dd></dl>

<hr>
<a name="UIOP_002fIMAGE"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fLISP_002dBUILD" accesskey="n" rel="next">UIOP/LISP-BUILD</a>, Previous: <a href="#UIOP_002fSTREAM" accesskey="p" rel="prev">UIOP/STREAM</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fIMAGE-1"></a>
<h2 class="chapter">10 UIOP/IMAGE</h2>

<a name="Function-uiop_002fimage_003aargv0"></a><dl>
<dt><a name="index-argv0"></a>Function: <strong>argv0</strong></dt>
<dd><a name="index-uiop_002fimage_003aargv0"></a>
<p>On supported implementations (most that matter), or when invoked by a proper wrapper script,
return a string that for the name with which the program was invoked, i.e. argv[0] in <code>c</code>.
Otherwise, return <code>nil</code>.
</p></dd></dl>
<a name="Function-uiop_002fimage_003acall_002dimage_002ddump_002dhook"></a><dl>
<dt><a name="index-call_002dimage_002ddump_002dhook"></a>Function: <strong>call-image-dump-hook</strong></dt>
<dd><a name="index-uiop_002fimage_003acall_002dimage_002ddump_002dhook"></a>
<p>Call the hook functions registered to be run before to dump an image
</p></dd></dl>
<a name="Function-uiop_002fimage_003acall_002dimage_002drestore_002dhook"></a><dl>
<dt><a name="index-call_002dimage_002drestore_002dhook"></a>Function: <strong>call-image-restore-hook</strong></dt>
<dd><a name="index-uiop_002fimage_003acall_002dimage_002drestore_002dhook"></a>
<p>Call the hook functions registered to be run when restoring a dumped image
</p></dd></dl>
<a name="Function-uiop_002fimage_003acall_002dwith_002dfatal_002dcondition_002dhandler"></a><dl>
<dt><a name="index-call_002dwith_002dfatal_002dcondition_002dhandler"></a>Function: <strong>call-with-fatal-condition-handler</strong> <em>thunk</em></dt>
<dd><a name="index-uiop_002fimage_003acall_002dwith_002dfatal_002dcondition_002dhandler"></a>
<p>Call <code>thunk</code> in a context where fatal conditions are appropriately handled
</p></dd></dl>
<a name="Function-uiop_002fimage_003acommand_002dline_002darguments"></a><dl>
<dt><a name="index-command_002dline_002darguments"></a>Function: <strong>command-line-arguments</strong> <em>&amp;optional  arguments</em></dt>
<dd><a name="index-uiop_002fimage_003acommand_002dline_002darguments"></a>
<p>Extract user arguments from command-line invocation of current process.
Assume the calling conventions of a generated script that uses <code>--</code>
if we are not called from a directly executable image.
</p></dd></dl>
<a name="Function-uiop_002fimage_003acreate_002dimage"></a><dl>
<dt><a name="index-create_002dimage"></a>Function: <strong>create-image</strong> <em>destination lisp-object-files &amp;key  kind output-name prologue-code epilogue-code extra-object-files prelude postlude entry-point build-args no-uiop</em></dt>
<dd><a name="index-uiop_002fimage_003acreate_002dimage"></a>
<p>On ECL, create an executable at pathname <code>destination</code> from the specified <code>object-files</code> and options
</p></dd></dl>
<a name="Function-uiop_002fimage_003adie"></a><dl>
<dt><a name="index-die"></a>Function: <strong>die</strong> <em>code format &amp;rest  arguments</em></dt>
<dd><a name="index-uiop_002fimage_003adie"></a>
<p>Die in error with some error message
</p></dd></dl>
<a name="Function-uiop_002fimage_003adump_002dimage"></a><dl>
<dt><a name="index-dump_002dimage"></a>Function: <strong>dump-image</strong> <em>filename &amp;key  output-name executable postlude dump-hook compression application-type</em></dt>
<dd><a name="index-uiop_002fimage_003adump_002dimage"></a>
<p>Dump an image of the current Lisp environment at pathname <code>filename</code>, with various options.
</p>
<p>First, finalize the image, by evaluating the <code>postlude</code> as per <code>eval-input</code>, then calling each of
 the functions in <code>dump-hook</code>, in reverse order of registration by <code>register-dump-hook</code>.
</p>
<p>If <code>executable</code> is true, create an standalone executable program that calls <code>restore-image</code> on startup.
</p>
<p>Pass various implementation-defined options, such as <code>prepend-symbols</code> and <code>purity</code> on CCL,
or <code>compression</code> on SBCL, and <code>application-type</code> on SBCL/Windows.
</p></dd></dl>
<a name="Function-uiop_002fimage_003afatal_002dcondition_002dp"></a><dl>
<dt><a name="index-fatal_002dcondition_002dp"></a>Function: <strong>fatal-condition-p</strong> <em>condition</em></dt>
<dd><a name="index-uiop_002fimage_003afatal_002dcondition_002dp"></a>
<p>Is the <code>condition</code> fatal?
</p></dd></dl>
<a name="Function-uiop_002fimage_003ahandle_002dfatal_002dcondition"></a><dl>
<dt><a name="index-handle_002dfatal_002dcondition"></a>Function: <strong>handle-fatal-condition</strong> <em>condition</em></dt>
<dd><a name="index-uiop_002fimage_003ahandle_002dfatal_002dcondition"></a>
<p>Handle a fatal <code>condition:</code>
depending on whether <code>*lisp-interaction*</code> is set, enter debugger or die
</p></dd></dl>
<a name="Function-uiop_002fimage_003aprint_002dbacktrace"></a><dl>
<dt><a name="index-print_002dbacktrace"></a>Function: <strong>print-backtrace</strong> <em>&amp;rest  keys &amp;key  stream count condition</em></dt>
<dd><a name="index-uiop_002fimage_003aprint_002dbacktrace"></a>
<p>Print a backtrace
</p></dd></dl>
<a name="Function-uiop_002fimage_003aprint_002dcondition_002dbacktrace"></a><dl>
<dt><a name="index-print_002dcondition_002dbacktrace"></a>Function: <strong>print-condition-backtrace</strong> <em>condition &amp;key  stream count</em></dt>
<dd><a name="index-uiop_002fimage_003aprint_002dcondition_002dbacktrace"></a>
<p>Print a condition after a backtrace triggered by that condition
</p></dd></dl>
<a name="Function-uiop_002fimage_003aquit"></a><dl>
<dt><a name="index-quit"></a>Function: <strong>quit</strong> <em>&amp;optional  code finish-output</em></dt>
<dd><a name="index-uiop_002fimage_003aquit"></a>
<p>Quits from the Lisp world, with the given exit status if provided.
This is designed to abstract away the implementation specific quit forms.
</p></dd></dl>
<a name="Function-uiop_002fimage_003araw_002dcommand_002dline_002darguments"></a><dl>
<dt><a name="index-raw_002dcommand_002dline_002darguments"></a>Function: <strong>raw-command-line-arguments</strong></dt>
<dd><a name="index-uiop_002fimage_003araw_002dcommand_002dline_002darguments"></a>
<p>Find what the actual command line for this process was.
</p></dd></dl>
<a name="Function-uiop_002fimage_003araw_002dprint_002dbacktrace"></a><dl>
<dt><a name="index-raw_002dprint_002dbacktrace"></a>Function: <strong>raw-print-backtrace</strong> <em>&amp;key  stream count condition</em></dt>
<dd><a name="index-uiop_002fimage_003araw_002dprint_002dbacktrace"></a>
<p>Print a backtrace, directly accessing the implementation
</p></dd></dl>
<a name="Function-uiop_002fimage_003aregister_002dimage_002ddump_002dhook"></a><dl>
<dt><a name="index-register_002dimage_002ddump_002dhook"></a>Function: <strong>register-image-dump-hook</strong> <em>hook &amp;optional  call-now-p</em></dt>
<dd><a name="index-uiop_002fimage_003aregister_002dimage_002ddump_002dhook"></a>
<p>Register a the hook function to be run before to dump an image
</p></dd></dl>
<a name="Function-uiop_002fimage_003aregister_002dimage_002drestore_002dhook"></a><dl>
<dt><a name="index-register_002dimage_002drestore_002dhook"></a>Function: <strong>register-image-restore-hook</strong> <em>hook &amp;optional  call-now-p</em></dt>
<dd><a name="index-uiop_002fimage_003aregister_002dimage_002drestore_002dhook"></a>
<p>Regiter a hook function to be run when restoring a dumped image
</p></dd></dl>
<a name="Function-uiop_002fimage_003arestore_002dimage"></a><dl>
<dt><a name="index-restore_002dimage"></a>Function: <strong>restore-image</strong> <em>&amp;key  lisp-interaction restore-hook prelude entry-point if-already-restored</em></dt>
<dd><a name="index-uiop_002fimage_003arestore_002dimage"></a>
<p>From a freshly restarted Lisp image, restore the saved Lisp environment
by setting appropriate variables, running various hooks, and calling any specified entry point.
</p>
<p>If the image has already been restored or is already being restored, as per <code>*image-restored-p*</code>,
call the <code>if-already-restored</code> error handler (by default, a continuable error), and do return
immediately to the surrounding restore process if allowed to continue.
</p>
<p>Then, comes the restore process itself:
First, call each function in the <code>restore-hook</code>,
in the order they were registered with <code>register-image-restore-hook</code>.
Second, evaluate the prelude, which is often Lisp text that is read,
as per <code>eval-input</code>.
Third, call the <code>entry-point</code> function, if any is specified, with no argument.
</p>
<p>The restore process happens in a <code>with-fatal-condition-handler</code>, so that if <code>lisp-interaction</code> is <code>nil</code>,
any unhandled error leads to a backtrace and an exit with an error status.
If <code>lisp-interaction</code> is <code>nil</code>, the process also exits when no error occurs:
if neither restart nor entry function is provided, the program will exit with status <code>0</code> (success);
if a function was provided, the program will exit after the function returns (if it returns),
with status <code>0</code> if and only if the primary return value of result is generalized boolean true,
and with status <code>1</code> if this value is <code>nil</code>.
</p>
<p>If <code>lisp-interaction</code> is true, unhandled errors will take you to the debugger, and the result
of the function will be returned rather than interpreted as a boolean designating an exit code.
</p></dd></dl>
<a name="Function-uiop_002fimage_003ashell_002dboolean_002dexit"></a><dl>
<dt><a name="index-shell_002dboolean_002dexit"></a>Function: <strong>shell-boolean-exit</strong> <em>x</em></dt>
<dd><a name="index-uiop_002fimage_003ashell_002dboolean_002dexit"></a>
<p>Quit with a return code that is <code>0</code> iff argument <code>x</code> is true
</p></dd></dl>
<a name="Macro-uiop_002fimage_003awith_002dfatal_002dcondition_002dhandler"></a><dl>
<dt><a name="index-with_002dfatal_002dcondition_002dhandler"></a>Macro: <strong>with-fatal-condition-handler</strong> <em>(&amp;optional) &amp;body  body</em></dt>
<dd><a name="index-uiop_002fimage_003awith_002dfatal_002dcondition_002dhandler"></a>
<p>Execute <code>body</code> in a context where fatal conditions are appropriately handled
</p></dd></dl>
<a name="Variable-uiop_002fimage_003a_002acommand_002dline_002darguments_002a"></a><dl>
<dt><a name="index-_002acommand_002dline_002darguments_002a"></a>Variable: <strong>*command-line-arguments*</strong></dt>
<dd><a name="index-uiop_002fimage_003a_002acommand_002dline_002darguments_002a"></a>
<p>Command-line arguments
</p></dd></dl>
<a name="Variable-uiop_002fimage_003a_002aimage_002ddump_002dhook_002a"></a><dl>
<dt><a name="index-_002aimage_002ddump_002dhook_002a"></a>Variable: <strong>*image-dump-hook*</strong></dt>
<dd><a name="index-uiop_002fimage_003a_002aimage_002ddump_002dhook_002a"></a>
<p>Functions to call (in order) when before an image is dumped
</p></dd></dl>
<a name="Variable-uiop_002fimage_003a_002aimage_002ddumped_002dp_002a"></a><dl>
<dt><a name="index-_002aimage_002ddumped_002dp_002a"></a>Variable: <strong>*image-dumped-p*</strong></dt>
<dd><a name="index-uiop_002fimage_003a_002aimage_002ddumped_002dp_002a"></a>
<p>Is this a dumped image? As a standalone executable?
</p></dd></dl>
<a name="Variable-uiop_002fimage_003a_002aimage_002dentry_002dpoint_002a"></a><dl>
<dt><a name="index-_002aimage_002dentry_002dpoint_002a"></a>Variable: <strong>*image-entry-point*</strong></dt>
<dd><a name="index-uiop_002fimage_003a_002aimage_002dentry_002dpoint_002a"></a>
<p>a function with which to restart the dumped image when execution is restored from it.
</p></dd></dl>
<a name="Variable-uiop_002fimage_003a_002aimage_002dpostlude_002a"></a><dl>
<dt><a name="index-_002aimage_002dpostlude_002a"></a>Variable: <strong>*image-postlude*</strong></dt>
<dd><a name="index-uiop_002fimage_003a_002aimage_002dpostlude_002a"></a>
<p>a form to evaluate, or string containing forms to read and evaluate
before the image dump hooks are called and before the image is dumped.
</p></dd></dl>
<a name="Variable-uiop_002fimage_003a_002aimage_002dprelude_002a"></a><dl>
<dt><a name="index-_002aimage_002dprelude_002a"></a>Variable: <strong>*image-prelude*</strong></dt>
<dd><a name="index-uiop_002fimage_003a_002aimage_002dprelude_002a"></a>
<p>a form to evaluate, or string containing forms to read and evaluate
when the image is restarted, but before the entry point is called.
</p></dd></dl>
<a name="Variable-uiop_002fimage_003a_002aimage_002drestore_002dhook_002a"></a><dl>
<dt><a name="index-_002aimage_002drestore_002dhook_002a"></a>Variable: <strong>*image-restore-hook*</strong></dt>
<dd><a name="index-uiop_002fimage_003a_002aimage_002drestore_002dhook_002a"></a>
<p>Functions to call (in reverse order) when the image is restored
</p></dd></dl>
<a name="Variable-uiop_002fimage_003a_002alisp_002dinteraction_002a"></a><dl>
<dt><a name="index-_002alisp_002dinteraction_002a"></a>Variable: <strong>*lisp-interaction*</strong></dt>
<dd><a name="index-uiop_002fimage_003a_002alisp_002dinteraction_002a"></a>
<p>Is this an interactive Lisp environment, or is it batch processing?
</p></dd></dl>

<hr>
<a name="UIOP_002fLISP_002dBUILD"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fLAUNCH_002dPROGRAM" accesskey="n" rel="next">UIOP/LAUNCH-PROGRAM</a>, Previous: <a href="#UIOP_002fIMAGE" accesskey="p" rel="prev">UIOP/IMAGE</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fLISP_002dBUILD-1"></a>
<h2 class="chapter">11 UIOP/LISP-BUILD</h2>

<a name="Function-uiop_002flisp_002dbuild_003acall_002daround_002dhook"></a><dl>
<dt><a name="index-call_002daround_002dhook"></a>Function: <strong>call-around-hook</strong> <em>hook function</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003acall_002daround_002dhook"></a>
<p>Call a <code>hook</code> around the execution of <code>function</code>
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003acall_002dwith_002dmuffled_002dcompiler_002dconditions"></a><dl>
<dt><a name="index-call_002dwith_002dmuffled_002dcompiler_002dconditions"></a>Function: <strong>call-with-muffled-compiler-conditions</strong> <em>thunk</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003acall_002dwith_002dmuffled_002dcompiler_002dconditions"></a>
<p>Call given <code>thunk</code> in a context where uninteresting conditions and compiler conditions are muffled
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003acall_002dwith_002dmuffled_002dloader_002dconditions"></a><dl>
<dt><a name="index-call_002dwith_002dmuffled_002dloader_002dconditions"></a>Function: <strong>call-with-muffled-loader-conditions</strong> <em>thunk</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003acall_002dwith_002dmuffled_002dloader_002dconditions"></a>
<p>Call given <code>thunk</code> in a context where uninteresting conditions and loader conditions are muffled
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003acheck_002ddeferred_002dwarnings"></a><dl>
<dt><a name="index-check_002ddeferred_002dwarnings"></a>Function: <strong>check-deferred-warnings</strong> <em>files &amp;optional  context-format context-arguments</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003acheck_002ddeferred_002dwarnings"></a>
<p>Given a list of <code>files</code> containing deferred warnings saved by <code>call-with-saved-deferred-warnings</code>,
re-intern and raise any warnings that are still meaningful.
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003acheck_002dlisp_002dcompile_002dresults"></a><dl>
<dt><a name="index-check_002dlisp_002dcompile_002dresults"></a>Function: <strong>check-lisp-compile-results</strong> <em>output warnings-p failure-p &amp;optional  context-format context-arguments</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003acheck_002dlisp_002dcompile_002dresults"></a>
<p>Given the results of <code>compile-file</code>, raise an error or warning as appropriate
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003acheck_002dlisp_002dcompile_002dwarnings"></a><dl>
<dt><a name="index-check_002dlisp_002dcompile_002dwarnings"></a>Function: <strong>check-lisp-compile-warnings</strong> <em>warnings-p failure-p &amp;optional  context-format context-arguments</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003acheck_002dlisp_002dcompile_002dwarnings"></a>
<p>Given the warnings or failures as resulted from <code>compile-file</code> or checking deferred warnings,
raise an error or warning as appropriate
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003acombine_002dfasls"></a><dl>
<dt><a name="index-combine_002dfasls"></a>Function: <strong>combine-fasls</strong> <em>inputs output</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003acombine_002dfasls"></a>
<p>Combine a list of FASLs <code>inputs</code> into a single FASL <code>output</code>
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003acompile_002dfile_002dpathname_002a"></a><dl>
<dt><a name="index-compile_002dfile_002dpathname_002a"></a>Function: <strong>compile-file-pathname*</strong> <em>input-file &amp;rest  keys &amp;key  output-file &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003acompile_002dfile_002dpathname_002a"></a>
<p>Variant of <code>compile-file-pathname</code> that works well with <code>compile-file*</code>
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003acompile_002dfile_002a"></a><dl>
<dt><a name="index-compile_002dfile_002a"></a>Function: <strong>compile-file*</strong> <em>input-file &amp;rest  keys &amp;key  compile-check output-file warnings-file emit-cfasl &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003acompile_002dfile_002a"></a>
<p>This function provides a portable wrapper around <code>compile-file</code>.
It ensures that the <code>output-file</code> value is only returned and
the file only actually created if the compilation was successful,
even though your implementation may not do that. It also checks an optional
user-provided consistency function <code>compile-check</code> to determine success;
it will call this function if not <code>nil</code> at the end of the compilation
with the arguments sent to <code>compile-file*</code>, except with <code>:output-file</code> <code>tmp-file</code>
where <code>tmp-file</code> is the name of a temporary output-file.
It also checks two flags (with legacy british spelling from <code>asdf1</code>),
<code>*compile-file-failure-behaviour*</code> and <code>*compile-file-warnings-behaviour*</code>
with appropriate implementation-dependent defaults,
and if a failure (respectively warnings) are reported by <code>compile-file</code>,
it will consider that an error unless the respective behaviour flag
is one of <code>:success</code> <code>:warn</code> <code>:ignore</code>.
If <code>warnings-file</code> is defined, deferred warnings are saved to that file.
On ECL or MKCL, it creates both the linkable object and loadable fasl files.
On implementations that erroneously do not recognize standard keyword arguments,
it will filter them appropriately.
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003acompile_002dfile_002dtype"></a><dl>
<dt><a name="index-compile_002dfile_002dtype"></a>Function: <strong>compile-file-type</strong> <em>&amp;rest  keys</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003acompile_002dfile_002dtype"></a>
<p>pathname <code>type</code> for lisp FASt Loading files
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003acurrent_002dlisp_002dfile_002dpathname"></a><dl>
<dt><a name="index-current_002dlisp_002dfile_002dpathname"></a>Function: <strong>current-lisp-file-pathname</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003acurrent_002dlisp_002dfile_002dpathname"></a>
<p>Portably return the <code>pathname</code> of the current Lisp source file being compiled or loaded
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003adisable_002ddeferred_002dwarnings_002dcheck"></a><dl>
<dt><a name="index-disable_002ddeferred_002dwarnings_002dcheck"></a>Function: <strong>disable-deferred-warnings-check</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003adisable_002ddeferred_002dwarnings_002dcheck"></a>
<p>Disable the saving of deferred warnings
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003aenable_002ddeferred_002dwarnings_002dcheck"></a><dl>
<dt><a name="index-enable_002ddeferred_002dwarnings_002dcheck"></a>Function: <strong>enable-deferred-warnings-check</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003aenable_002ddeferred_002dwarnings_002dcheck"></a>
<p>Enable the saving of deferred warnings
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003aget_002doptimization_002dsettings"></a><dl>
<dt><a name="index-get_002doptimization_002dsettings"></a>Function: <strong>get-optimization-settings</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003aget_002doptimization_002dsettings"></a>
<p>Get current compiler optimization settings, ready to <code>proclaim</code> again
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003alispize_002dpathname"></a><dl>
<dt><a name="index-lispize_002dpathname"></a>Function: <strong>lispize-pathname</strong> <em>input-file</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003alispize_002dpathname"></a>
<p>From a <code>input-file</code> pathname, return a corresponding .lisp source pathname
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003aload_002dfrom_002dstring"></a><dl>
<dt><a name="index-load_002dfrom_002dstring"></a>Function: <strong>load-from-string</strong> <em>string</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003aload_002dfrom_002dstring"></a>
<p>Portably read and evaluate forms from a <code>string</code>.
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003aload_002dpathname"></a><dl>
<dt><a name="index-load_002dpathname"></a>Function: <strong>load-pathname</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003aload_002dpathname"></a>
<p>Portably return the <code>load-pathname</code> of the current source file or fasl
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003aload_002a"></a><dl>
<dt><a name="index-load_002a"></a>Function: <strong>load*</strong> <em>x &amp;rest  keys &amp;key  &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003aload_002a"></a>
<p>Portable wrapper around <code>load</code> that properly handles loading from a stream.
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003aproclaim_002doptimization_002dsettings"></a><dl>
<dt><a name="index-proclaim_002doptimization_002dsettings"></a>Function: <strong>proclaim-optimization-settings</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003aproclaim_002doptimization_002dsettings"></a>
<p>Proclaim the optimization settings in <code>*optimization-settings*</code>
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003areify_002ddeferred_002dwarnings"></a><dl>
<dt><a name="index-reify_002ddeferred_002dwarnings"></a>Function: <strong>reify-deferred-warnings</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003areify_002ddeferred_002dwarnings"></a>
<p>return a portable S-expression, portably readable and writeable in any Common Lisp implementation
using <code>read</code> within a <code>with-safe-io-syntax</code>, that represents the warnings currently deferred by
<code>with-compilation-unit</code>. One of three functions required for deferred-warnings support in ASDF.
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003areify_002dsimple_002dsexp"></a><dl>
<dt><a name="index-reify_002dsimple_002dsexp"></a>Function: <strong>reify-simple-sexp</strong> <em>sexp</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003areify_002dsimple_002dsexp"></a>
<p>Given a simple <code>sexp</code>, return a representation of it as a portable <code>sexp</code>.
Simple means made of symbols, numbers, characters, simple-strings, pathnames, cons cells.
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003areset_002ddeferred_002dwarnings"></a><dl>
<dt><a name="index-reset_002ddeferred_002dwarnings"></a>Function: <strong>reset-deferred-warnings</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003areset_002ddeferred_002dwarnings"></a>
<p>Reset the set of deferred warnings to be handled at the end of the current <code>with-compilation-unit</code>.
One of three functions required for deferred-warnings support in ASDF.
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003asave_002ddeferred_002dwarnings"></a><dl>
<dt><a name="index-save_002ddeferred_002dwarnings"></a>Function: <strong>save-deferred-warnings</strong> <em>warnings-file</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003asave_002ddeferred_002dwarnings"></a>
<p>Save forward reference conditions so they may be issued at a latter time,
possibly in a different process.
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003aunreify_002ddeferred_002dwarnings"></a><dl>
<dt><a name="index-unreify_002ddeferred_002dwarnings"></a>Function: <strong>unreify-deferred-warnings</strong> <em>reified-deferred-warnings</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003aunreify_002ddeferred_002dwarnings"></a>
<p>given a S-expression created by <code>reify-deferred-warnings</code>, reinstantiate the corresponding
deferred warnings as to be handled at the end of the current <code>with-compilation-unit</code>.
Handle any warning that has been resolved already,
such as an undefined function that has been defined since.
One of three functions required for deferred-warnings support in ASDF.
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003aunreify_002dsimple_002dsexp"></a><dl>
<dt><a name="index-unreify_002dsimple_002dsexp"></a>Function: <strong>unreify-simple-sexp</strong> <em>sexp</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003aunreify_002dsimple_002dsexp"></a>
<p>Given the portable output of <code>reify-simple-sexp</code>, return the simple <code>sexp</code> it represents
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003awarnings_002dfile_002dp"></a><dl>
<dt><a name="index-warnings_002dfile_002dp"></a>Function: <strong>warnings-file-p</strong> <em>file &amp;optional  implementation-type</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003awarnings_002dfile_002dp"></a>
<p>Is <code>file</code> a saved warnings file for the given <code>implementation-type</code>?
If that given type is <code>nil</code>, use the currently configured <code>*warnings-file-type*</code> instead.
</p></dd></dl>
<a name="Function-uiop_002flisp_002dbuild_003awarnings_002dfile_002dtype"></a><dl>
<dt><a name="index-warnings_002dfile_002dtype"></a>Function: <strong>warnings-file-type</strong> <em>&amp;optional  implementation-type</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003awarnings_002dfile_002dtype"></a>
<p>The pathname type for warnings files on given <code>implementation-type</code>,
where <code>nil</code> designates the current one
</p></dd></dl>
<a name="Macro-uiop_002flisp_002dbuild_003awith_002dmuffled_002dcompiler_002dconditions"></a><dl>
<dt><a name="index-with_002dmuffled_002dcompiler_002dconditions"></a>Macro: <strong>with-muffled-compiler-conditions</strong> <em>(&amp;optional) &amp;body  body</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003awith_002dmuffled_002dcompiler_002dconditions"></a>
<p>Trivial syntax for <code>call-with-muffled-compiler-conditions</code>
</p></dd></dl>
<a name="Macro-uiop_002flisp_002dbuild_003awith_002dmuffled_002dloader_002dconditions"></a><dl>
<dt><a name="index-with_002dmuffled_002dloader_002dconditions"></a>Macro: <strong>with-muffled-loader-conditions</strong> <em>(&amp;optional) &amp;body  body</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003awith_002dmuffled_002dloader_002dconditions"></a>
<p>Trivial syntax for <code>call-with-muffled-loader-conditions</code>
</p></dd></dl>
<a name="Macro-uiop_002flisp_002dbuild_003awith_002dsaved_002ddeferred_002dwarnings"></a><dl>
<dt><a name="index-with_002dsaved_002ddeferred_002dwarnings"></a>Macro: <strong>with-saved-deferred-warnings</strong> <em>(warnings-file &amp;key source-namestring) &amp;body  body</em></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003awith_002dsaved_002ddeferred_002dwarnings"></a>
<p>Trivial syntax for <code>call-with-saved-deferred-warnings</code>
</p></dd></dl>
<a name="Variable-uiop_002flisp_002dbuild_003a_002abase_002dbuild_002ddirectory_002a"></a><dl>
<dt><a name="index-_002abase_002dbuild_002ddirectory_002a"></a>Variable: <strong>*base-build-directory*</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003a_002abase_002dbuild_002ddirectory_002a"></a>
<p>When set to a non-null value, it should be an absolute directory pathname,
which will serve as the <code>*default-pathname-defaults*</code> around a <code>compile-file</code>,
what more while the input-file is shortened if possible to <code>enough-pathname</code> relative to it.
This can help you produce more deterministic output for FASLs.
</p></dd></dl>
<a name="Variable-uiop_002flisp_002dbuild_003a_002acompile_002dcheck_002a"></a><dl>
<dt><a name="index-_002acompile_002dcheck_002a"></a>Variable: <strong>*compile-check*</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003a_002acompile_002dcheck_002a"></a>
<p>A hook for user-defined compile-time invariants
</p></dd></dl>
<a name="Variable-uiop_002flisp_002dbuild_003a_002acompile_002dfile_002dfailure_002dbehaviour_002a"></a><dl>
<dt><a name="index-_002acompile_002dfile_002dfailure_002dbehaviour_002a"></a>Variable: <strong>*compile-file-failure-behaviour*</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003a_002acompile_002dfile_002dfailure_002dbehaviour_002a"></a>
<p>How should ASDF react if it encounters a failure (per the ANSI spec of <code>compile-file</code>)
when compiling a file, which includes any non-style-warning warning.
Valid values are :error, :warn, and :ignore.
Note that ASDF <code>always</code> raises an error if it fails to create an output file when compiling.
</p></dd></dl>
<a name="Variable-uiop_002flisp_002dbuild_003a_002acompile_002dfile_002dwarnings_002dbehaviour_002a"></a><dl>
<dt><a name="index-_002acompile_002dfile_002dwarnings_002dbehaviour_002a"></a>Variable: <strong>*compile-file-warnings-behaviour*</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003a_002acompile_002dfile_002dwarnings_002dbehaviour_002a"></a>
<p>How should ASDF react if it encounters a warning when compiling a file?
Valid values are :error, :warn, and :ignore.
</p></dd></dl>
<a name="Variable-uiop_002flisp_002dbuild_003a_002aoptimization_002dsettings_002a"></a><dl>
<dt><a name="index-_002aoptimization_002dsettings_002a"></a>Variable: <strong>*optimization-settings*</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003a_002aoptimization_002dsettings_002a"></a>
<p>Optimization settings to be used by <code>proclaim-optimization-settings</code>
</p></dd></dl>
<a name="Variable-uiop_002flisp_002dbuild_003a_002aoutput_002dtranslation_002dfunction_002a"></a><dl>
<dt><a name="index-_002aoutput_002dtranslation_002dfunction_002a-1"></a>Variable: <strong>*output-translation-function*</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003a_002aoutput_002dtranslation_002dfunction_002a"></a>
<p>Hook for output translations.
</p>
<p>This function needs to be idempotent, so that actions can work
whether their inputs were translated or not,
which they will be if we are composing operations. e.g. if some
create-lisp-op creates a lisp file from some higher-level input,
you need to still be able to use compile-op on that lisp file.
</p></dd></dl>
<a name="Variable-uiop_002flisp_002dbuild_003a_002aprevious_002doptimization_002dsettings_002a"></a><dl>
<dt><a name="index-_002aprevious_002doptimization_002dsettings_002a"></a>Variable: <strong>*previous-optimization-settings*</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003a_002aprevious_002doptimization_002dsettings_002a"></a>
<p>Optimization settings saved by <code>proclaim-optimization-settings</code>
</p></dd></dl>
<a name="Variable-uiop_002flisp_002dbuild_003a_002auninteresting_002dcompiler_002dconditions_002a"></a><dl>
<dt><a name="index-_002auninteresting_002dcompiler_002dconditions_002a"></a>Variable: <strong>*uninteresting-compiler-conditions*</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003a_002auninteresting_002dcompiler_002dconditions_002a"></a>
<p>Additional conditions that may be skipped while compiling Lisp code.
</p></dd></dl>
<a name="Variable-uiop_002flisp_002dbuild_003a_002auninteresting_002dconditions_002a"></a><dl>
<dt><a name="index-_002auninteresting_002dconditions_002a"></a>Variable: <strong>*uninteresting-conditions*</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003a_002auninteresting_002dconditions_002a"></a>
<p>Conditions that may be skipped while compiling or loading Lisp code.
</p></dd></dl>
<a name="Variable-uiop_002flisp_002dbuild_003a_002auninteresting_002dloader_002dconditions_002a"></a><dl>
<dt><a name="index-_002auninteresting_002dloader_002dconditions_002a"></a>Variable: <strong>*uninteresting-loader-conditions*</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003a_002auninteresting_002dloader_002dconditions_002a"></a>
<p>Additional conditions that may be skipped while loading Lisp code.
</p></dd></dl>
<a name="Variable-uiop_002flisp_002dbuild_003a_002ausual_002duninteresting_002dconditions_002a"></a><dl>
<dt><a name="index-_002ausual_002duninteresting_002dconditions_002a"></a>Variable: <strong>*usual-uninteresting-conditions*</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003a_002ausual_002duninteresting_002dconditions_002a"></a>
<p>A suggested value to which to set or bind *uninteresting-conditions*.
</p></dd></dl>
<a name="Variable-uiop_002flisp_002dbuild_003a_002awarnings_002dfile_002dtype_002a"></a><dl>
<dt><a name="index-_002awarnings_002dfile_002dtype_002a"></a>Variable: <strong>*warnings-file-type*</strong></dt>
<dd><a name="index-uiop_002flisp_002dbuild_003a_002awarnings_002dfile_002dtype_002a"></a>
<p>Pathname type for warnings files, or <code>nil</code> if disabled
</p></dd></dl>

<hr>
<a name="UIOP_002fLAUNCH_002dPROGRAM"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fRUN_002dPROGRAM" accesskey="n" rel="next">UIOP/RUN-PROGRAM</a>, Previous: <a href="#UIOP_002fLISP_002dBUILD" accesskey="p" rel="prev">UIOP/LISP-BUILD</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fLAUNCH_002dPROGRAM-1"></a>
<h2 class="chapter">12 UIOP/LAUNCH-PROGRAM</h2>

<p><code>uiop/launch-program</code> semi-portably launches a program as an
asynchronous external subprocess. Available functionality may depend
on the underlying implementation.
</p>
<a name="Function-uiop_002flaunch_002dprogram_003aclose_002dstreams"></a><dl>
<dt><a name="index-close_002dstreams"></a>Function: <strong>close-streams</strong> <em>process-info</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003aclose_002dstreams"></a>
<p>Close any stream that the process might own. Needs to be run
whenever streams were requested by passing :stream to :input, :output,
or :error-output.
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003aeasy_002dsh_002dcharacter_002dp"></a><dl>
<dt><a name="index-easy_002dsh_002dcharacter_002dp"></a>Function: <strong>easy-sh-character-p</strong> <em>x</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003aeasy_002dsh_002dcharacter_002dp"></a>
<p>Is <code>x</code> an &quot;easy&quot; character that does not require quoting by the shell?
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003aescape_002dcommand"></a><dl>
<dt><a name="index-escape_002dcommand"></a>Function: <strong>escape-command</strong> <em>command &amp;optional  s escaper</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003aescape_002dcommand"></a>
<p>Given a <code>command</code> as a list of tokens, return a string of the
spaced, escaped tokens, using <code>escaper</code> to escape.
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003aescape_002dsh_002dcommand"></a><dl>
<dt><a name="index-escape_002dsh_002dcommand"></a>Function: <strong>escape-sh-command</strong> <em>command &amp;optional  s</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003aescape_002dsh_002dcommand"></a>
<p>Escape a list of command-line arguments into a string suitable for parsing
by /bin/sh in POSIX
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003aescape_002dsh_002dtoken"></a><dl>
<dt><a name="index-escape_002dsh_002dtoken"></a>Function: <strong>escape-sh-token</strong> <em>token &amp;optional  s</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003aescape_002dsh_002dtoken"></a>
<p>Escape a string <code>token</code> within double-quotes if needed
for use within a POSIX Bourne shell, outputing to <code>s</code>.
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003aescape_002dshell_002dcommand"></a><dl>
<dt><a name="index-escape_002dshell_002dcommand"></a>Function: <strong>escape-shell-command</strong> <em>command &amp;optional  stream</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003aescape_002dshell_002dcommand"></a>
<p>Escape a command for the current operating system&rsquo;s shell
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003aescape_002dshell_002dtoken"></a><dl>
<dt><a name="index-escape_002dshell_002dtoken"></a>Function: <strong>escape-shell-token</strong> <em>token &amp;optional  s</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003aescape_002dshell_002dtoken"></a>
<p>Escape a token for the current operating system shell
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003aescape_002dtoken"></a><dl>
<dt><a name="index-escape_002dtoken"></a>Function: <strong>escape-token</strong> <em>token &amp;key  stream quote good-chars bad-chars escaper</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003aescape_002dtoken"></a>
<p>Call the <code>escaper</code> function on <code>token</code> string if it needs escaping as per
<code>requires-escaping-p</code> using <code>good-chars</code> and <code>bad-chars</code>, otherwise output <code>token</code>,
using <code>stream</code> as output (or returning result as a string if <code>nil</code>)
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003aescape_002dwindows_002dcommand"></a><dl>
<dt><a name="index-escape_002dwindows_002dcommand"></a>Function: <strong>escape-windows-command</strong> <em>command &amp;optional  s</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003aescape_002dwindows_002dcommand"></a>
<p>Escape a list of command-line arguments into a string suitable for parsing
by CommandLineToArgv in <code>ms</code> Windows
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003aescape_002dwindows_002dtoken"></a><dl>
<dt><a name="index-escape_002dwindows_002dtoken"></a>Function: <strong>escape-windows-token</strong> <em>token &amp;optional  s</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003aescape_002dwindows_002dtoken"></a>
<p>Escape a string <code>token</code> within double-quotes if needed
for use within a <code>ms</code> Windows command-line, outputing to <code>s</code>.
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003alaunch_002dprogram"></a><dl>
<dt><a name="index-launch_002dprogram"></a>Function: <strong>launch-program</strong> <em>command &amp;rest  keys &amp;key  input if-input-does-not-exist output if-output-exists error-output if-error-output-exists element-type external-format directory &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003alaunch_002dprogram"></a>
<p>Launch program specified by <code>command</code>,
either a list of strings specifying a program and list of arguments,
or a string specifying a shell command (/bin/sh on Unix, <code>cmd</code>.<code>exe</code> on
Windows) _asynchronously_.
</p>
<p>If <code>output</code> is a pathname, a string designating a pathname, or <code>nil</code> (the
default) designating the null device, the file at that path is used as
output.
If it&rsquo;s <code>:interactive</code>, output is inherited from the current process;
beware that this may be different from your <code>*standard-output*</code>, and
under <code>slime</code> will be on your *inferior-lisp* buffer.  If it&rsquo;s <code>t</code>, output
goes to your current <code>*standard-output*</code> stream.  If it&rsquo;s <code>:stream</code>, a new
stream will be made available that can be accessed via
<code>process-info-output</code> and read from. Otherwise, <code>output</code> should be a value
that the underlying lisp implementation knows how to handle.
</p>
<p><code>if-output-exists</code>, which is only meaningful if <code>output</code> is a string or a
pathname, can take the values <code>:error</code>, <code>:append</code>, and <code>:supersede</code> (the
default). The meaning of these values and their effect on the case
where <code>output</code> does not exist, is analogous to the <code>if-exists</code> parameter
to <code>open</code> with <code>:direction</code> <code>:output</code>.
</p>
<p><code>error-output</code> is similar to <code>output</code>. <code>t</code> designates the <code>*error-output*</code>,
<code>:output</code> means redirecting the error output to the output stream,
and <code>:stream</code> causes a stream to be made available via
<code>process-info-error-output</code>.
</p>
<p><code>if-error-output-exists</code> is similar to <code>if-output-exist</code>, except that it
affects <code>error-output</code> rather than <code>output</code>.
</p>
<p><code>input</code> is similar to <code>output</code>, except that <code>t</code> designates the
<code>*standard-input*</code> and a stream requested through the <code>:stream</code> keyword
would be available through <code>process-info-input</code>.
</p>
<p><code>if-input-does-not-exist</code>, which is only meaningful if <code>input</code> is a string
or a pathname, can take the values <code>:create</code> and <code>:error</code> (the
default). The meaning of these values is analogous to the
<code>if-does-not-exist</code> parameter to <code>open</code> with <code>:direction</code> <code>:input</code>.
</p>
<p><code>element-type</code> and <code>external-format</code> are passed on to your Lisp
implementation, when applicable, for creation of the output stream.
</p>
<p><code>launch-program</code> returns a <code>process-info</code> object.
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003aprocess_002dalive_002dp"></a><dl>
<dt><a name="index-process_002dalive_002dp"></a>Function: <strong>process-alive-p</strong> <em>process-info</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003aprocess_002dalive_002dp"></a>
<p>Check if a process has yet to exit.
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003aterminate_002dprocess"></a><dl>
<dt><a name="index-terminate_002dprocess"></a>Function: <strong>terminate-process</strong> <em>process-info &amp;key  urgent</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003aterminate_002dprocess"></a>
<p>Cause the process to exit. To that end, the process may or may
not be sent a signal, which it will find harder (or even impossible)
to ignore if <code>urgent</code> is <code>t</code>. On some platforms, it may also be subject to
race conditions.
</p></dd></dl>
<a name="Function-uiop_002flaunch_002dprogram_003await_002dprocess"></a><dl>
<dt><a name="index-wait_002dprocess"></a>Function: <strong>wait-process</strong> <em>process-info</em></dt>
<dd><a name="index-uiop_002flaunch_002dprogram_003await_002dprocess"></a>
<p>Wait for the process to terminate, if it is still running.
Otherwise, return immediately. An exit code (a number) will be
returned, with <code>0</code> indicating success, and anything else indicating
failure. If the process exits after receiving a signal, the exit code
will be the sum of <code>128</code> and the (positive) numeric signal code. A second
value may be returned in this case: the numeric signal code itself.
Any asynchronously spawned process requires this function to be run
before it is garbage-collected in order to free up resources that
might otherwise be irrevocably lost.
</p></dd></dl>

<hr>
<a name="UIOP_002fRUN_002dPROGRAM"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fCONFIGURATION" accesskey="n" rel="next">UIOP/CONFIGURATION</a>, Previous: <a href="#UIOP_002fLAUNCH_002dPROGRAM" accesskey="p" rel="prev">UIOP/LAUNCH-PROGRAM</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fRUN_002dPROGRAM-1"></a>
<h2 class="chapter">13 UIOP/RUN-PROGRAM</h2>

<p><code>uiop/run-program</code> fully portably runs a program as a synchronous
external subprocess.
</p>
<a name="Function-uiop_002frun_002dprogram_003arun_002dprogram"></a><dl>
<dt><a name="index-run_002dprogram"></a>Function: <strong>run-program</strong> <em>command &amp;rest  keys &amp;key  ignore-error-status force-shell input if-input-does-not-exist output if-output-exists error-output if-error-output-exists element-type external-format &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002frun_002dprogram_003arun_002dprogram"></a>
<p>Run program specified by <code>command</code>,
either a list of strings specifying a program and list of arguments,
or a string specifying a shell command (/bin/sh on Unix, <code>cmd</code>.<code>exe</code> on Windows);
_synchronously_ process its output as specified and return the processing results
when the program and its output processing are complete.
</p>
<p>Always call a shell (rather than directly execute the command when possible)
if <code>force-shell</code> is specified.  Similarly, never call a shell if <code>force-shell</code> is
specified to be <code>nil</code>.
</p>
<p>Signal a continuable <code>subprocess-error</code> if the process wasn&rsquo;t successful (exit-code <code>0</code>),
unless <code>ignore-error-status</code> is specified.
</p>
<p>If <code>output</code> is a pathname, a string designating a pathname, or <code>nil</code> (the default)
designating the null device, the file at that path is used as output.
If it&rsquo;s <code>:interactive</code>, output is inherited from the current process;
beware that this may be different from your <code>*standard-output*</code>,
and under <code>slime</code> will be on your *inferior-lisp* buffer.
If it&rsquo;s <code>t</code>, output goes to your current <code>*standard-output*</code> stream.
Otherwise, <code>output</code> should be a value that is a suitable first argument to
<code>slurp-input-stream</code> (qv.), or a list of such a value and keyword arguments.
In this case, <code>run-program</code> will create a temporary stream for the program output;
the program output, in that stream, will be processed by a call to <code>slurp-input-stream</code>,
using <code>output</code> as the first argument (or the first element of <code>output</code>, and the rest as keywords).
The primary value resulting from that call (or <code>nil</code> if no call was needed)
will be the first value returned by <code>run-program</code>.
<code>e</code>.g., using <code>:output</code> <code>:string</code> will have it return the entire output stream as a string.
And using <code>:output</code> &rsquo;(<code>:string</code> <code>:stripped</code> <code>t</code>) will have it return the same string
stripped of any ending newline.
</p>
<p><code>if-output-exists</code>, which is only meaningful if <code>output</code> is a string or a
pathname, can take the values <code>:error</code>, <code>:append</code>, and <code>:supersede</code> (the
default). The meaning of these values and their effect on the case
where <code>output</code> does not exist, is analogous to the <code>if-exists</code> parameter
to <code>open</code> with <code>:direction</code> <code>:output</code>.
</p>
<p><code>error-output</code> is similar to <code>output</code>, except that the resulting value is returned
as the second value of <code>run-program</code>. <code>t</code> designates the <code>*error-output*</code>.
Also <code>:output</code> means redirecting the error output to the output stream,
in which case <code>nil</code> is returned.
</p>
<p><code>if-error-output-exists</code> is similar to <code>if-output-exist</code>, except that it
affects <code>error-output</code> rather than <code>output</code>.
</p>
<p><code>input</code> is similar to <code>output</code>, except that <code>vomit-output-stream</code> is used,
no value is returned, and <code>t</code> designates the <code>*standard-input*</code>.
</p>
<p><code>if-input-does-not-exist</code>, which is only meaningful if <code>input</code> is a string
or a pathname, can take the values <code>:create</code> and <code>:error</code> (the
default). The meaning of these values is analogous to the
<code>if-does-not-exist</code> parameter to <code>open</code> with <code>:direction</code> <code>:input</code>.
</p>
<p><code>element-type</code> and <code>external-format</code> are passed on
to your Lisp implementation, when applicable, for creation of the output stream.
</p>
<p>One and only one of the stream slurping or vomiting may or may not happen
in parallel in parallel with the subprocess,
depending on options and implementation,
and with priority being given to output processing.
Other streams are completely produced or consumed
before or after the subprocess is spawned, using temporary files.
</p>
<p><code>run-program</code> returns <code>3</code> values:
<code>0-</code> the result of the <code>output</code> slurping if any, or <code>nil</code>
<code>1-</code> the result of the <code>error-output</code> slurping if any, or <code>nil</code>
<code>2-</code> either <code>0</code> if the subprocess exited with success status,
or an indication of failure via the <code>exit-code</code> of the process
</p></dd></dl>
<a name="Generic_002dFunction-uiop_002frun_002dprogram_003aslurp_002dinput_002dstream"></a><dl>
<dt><a name="index-slurp_002dinput_002dstream"></a>Generic Function: <strong>slurp-input-stream</strong> <em>processor input-stream &amp;key  linewise prefix element-type buffer-size external-format if-exists if-does-not-exist at count stripped &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002frun_002dprogram_003aslurp_002dinput_002dstream"></a>
<p><code>slurp-input-stream</code> is a generic function with two positional arguments
<code>processor</code> and <code>input-stream</code> and additional keyword arguments, that consumes (slurps)
the contents of the <code>input-stream</code> and processes them according to a method
specified by <code>processor</code>.
</p>
<p>Built-in methods include the following:
</p><ul>
<li> if <code>processor</code> is a function, it is called with the <code>input-stream</code> as its argument
</li><li> if <code>processor</code> is a list, its first element should be a function.  It will be applied to a cons of the
  <code>input-stream</code> and the rest of the list.  That is (x . y) will be treated as
    (<code>apply</code> x &lt;stream&gt; y)
</li><li> if <code>processor</code> is an output-stream, the contents of <code>input-stream</code> is copied to the output-stream,
  per copy-stream-to-stream, with appropriate keyword arguments.
</li><li> if <code>processor</code> is the symbol <code>cl:string</code> or the keyword <code>:string</code>, then the contents of <code>input-stream</code>
  are returned as a string, as per <code>slurp-stream-string</code>.
</li><li> if <code>processor</code> is the keyword <code>:lines</code> then the <code>input-stream</code> will be handled by <code>slurp-stream-lines</code>.
</li><li> if <code>processor</code> is the keyword <code>:line</code> then the <code>input-stream</code> will be handled by <code>slurp-stream-line</code>.
</li><li> if <code>processor</code> is the keyword <code>:forms</code> then the <code>input-stream</code> will be handled by <code>slurp-stream-forms</code>.
</li><li> if <code>processor</code> is the keyword <code>:form</code> then the <code>input-stream</code> will be handled by <code>slurp-stream-form</code>.
</li><li> if <code>processor</code> is <code>t</code>, it is treated the same as *standard-output*. If it is <code>nil</code>, <code>nil</code> is returned.

</li></ul>
<p>Programmers are encouraged to define their own methods for this generic function.
</p></dd></dl>
<a name="Generic_002dFunction-uiop_002frun_002dprogram_003avomit_002doutput_002dstream"></a><dl>
<dt><a name="index-vomit_002doutput_002dstream"></a>Generic Function: <strong>vomit-output-stream</strong> <em>processor output-stream &amp;key  linewise prefix element-type buffer-size external-format if-exists if-does-not-exist fresh-line terpri &amp;allow-other-keys </em></dt>
<dd><a name="index-uiop_002frun_002dprogram_003avomit_002doutput_002dstream"></a>
<p><code>vomit-output-stream</code> is a generic function with two positional arguments
<code>processor</code> and <code>output-stream</code> and additional keyword arguments, that produces (vomits)
some content onto the <code>output-stream</code>, according to a method specified by <code>processor</code>.
</p>
<p>Built-in methods include the following:
</p><ul>
<li> if <code>processor</code> is a function, it is called with the <code>output-stream</code> as its argument
</li><li> if <code>processor</code> is a list, its first element should be a function.
  It will be applied to a cons of the <code>output-stream</code> and the rest of the list.
  That is (x . y) will be treated as (<code>apply</code> x &lt;stream&gt; y)
</li><li> if <code>processor</code> is an input-stream, its contents will be copied the <code>output-stream</code>,
  per copy-stream-to-stream, with appropriate keyword arguments.
</li><li> if <code>processor</code> is a string, its contents will be printed to the <code>output-stream</code>.
</li><li> if <code>processor</code> is <code>t</code>, it is treated the same as *standard-input*. If it is <code>nil</code>, nothing is done.

</li></ul>
<p>Programmers are encouraged to define their own methods for this generic function.
</p></dd></dl>

<hr>
<a name="UIOP_002fCONFIGURATION"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fBACKWARD_002dDRIVER" accesskey="n" rel="next">UIOP/BACKWARD-DRIVER</a>, Previous: <a href="#UIOP_002fRUN_002dPROGRAM" accesskey="p" rel="prev">UIOP/RUN-PROGRAM</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fCONFIGURATION-1"></a>
<h2 class="chapter">14 UIOP/CONFIGURATION</h2>

<a name="Function-uiop_002fconfiguration_003aclear_002dconfiguration"></a><dl>
<dt><a name="index-clear_002dconfiguration"></a>Function: <strong>clear-configuration</strong></dt>
<dd><a name="index-uiop_002fconfiguration_003aclear_002dconfiguration"></a>
<p>Call the functions in <code>*clear-configuration-hook*</code>
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003aconfiguration_002dinheritance_002ddirective_002dp"></a><dl>
<dt><a name="index-configuration_002dinheritance_002ddirective_002dp"></a>Function: <strong>configuration-inheritance-directive-p</strong> <em>x</em></dt>
<dd><a name="index-uiop_002fconfiguration_003aconfiguration_002dinheritance_002ddirective_002dp"></a>
<p>Is <code>x</code> a configuration inheritance directive?
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003afilter_002dpathname_002dset"></a><dl>
<dt><a name="index-filter_002dpathname_002dset"></a>Function: <strong>filter-pathname-set</strong> <em>dirs</em></dt>
<dd><a name="index-uiop_002fconfiguration_003afilter_002dpathname_002dset"></a>
<p>Parse strings as unix namestrings and remove duplicates and non absolute-pathnames in a list.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003afind_002dpreferred_002dfile"></a><dl>
<dt><a name="index-find_002dpreferred_002dfile"></a>Function: <strong>find-preferred-file</strong> <em>files &amp;key  direction</em></dt>
<dd><a name="index-uiop_002fconfiguration_003afind_002dpreferred_002dfile"></a>
<p>Find first file in the list of <code>files</code> that exists (for direction :input or :probe)
or just the first one (for direction :output or :io).
    Note that when we say &quot;file&quot; here, the files in question may be directories.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003aget_002dfolder_002dpath"></a><dl>
<dt><a name="index-get_002dfolder_002dpath"></a>Function: <strong>get-folder-path</strong> <em>folder</em></dt>
<dd><a name="index-uiop_002fconfiguration_003aget_002dfolder_002dpath"></a>
<p>Semi-portable implementation of a subset of LispWorks&rsquo; sys:get-folder-path,
this function tries to locate the Windows <code>folder</code> for one of
<code>:local-appdata</code>, <code>:appdata</code> or <code>:common-appdata</code>.
     Returns <code>nil</code> when the folder is not defined (e.g., not on Windows).
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003ain_002dfirst_002ddirectory"></a><dl>
<dt><a name="index-in_002dfirst_002ddirectory"></a>Function: <strong>in-first-directory</strong> <em>dirs x &amp;key  direction</em></dt>
<dd><a name="index-uiop_002fconfiguration_003ain_002dfirst_002ddirectory"></a>
<p>Finds the first appropriate file named <code>x</code> in the list of <code>dirs</code> for I/O
in <code>direction</code> (which may be <code>:input</code>, <code>:output</code>, <code>:io</code>, or <code>:probe</code>).
If direction is <code>:input</code> or <code>:probe</code>, will return the first extant file named
<code>x</code> in one of the <code>dirs</code>.
If direction is <code>:output</code> or <code>:io</code>, will simply return the file named <code>x</code> in the
first element of <code>dirs</code> that exists. <code>deprecated</code>.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003ain_002dsystem_002dconfiguration_002ddirectory"></a><dl>
<dt><a name="index-in_002dsystem_002dconfiguration_002ddirectory"></a>Function: <strong>in-system-configuration-directory</strong> <em>x &amp;key  direction</em></dt>
<dd><a name="index-uiop_002fconfiguration_003ain_002dsystem_002dconfiguration_002ddirectory"></a>
<p>Return the pathname for the file named <code>x</code> under the system configuration directory
for common-lisp. <code>deprecated</code>.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003ain_002duser_002dconfiguration_002ddirectory"></a><dl>
<dt><a name="index-in_002duser_002dconfiguration_002ddirectory"></a>Function: <strong>in-user-configuration-directory</strong> <em>x &amp;key  direction</em></dt>
<dd><a name="index-uiop_002fconfiguration_003ain_002duser_002dconfiguration_002ddirectory"></a>
<p>Return the file named <code>x</code> in the user configuration directory for common-lisp.
<code>deprecated</code>.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003alocation_002ddesignator_002dp"></a><dl>
<dt><a name="index-location_002ddesignator_002dp"></a>Function: <strong>location-designator-p</strong> <em>x</em></dt>
<dd><a name="index-uiop_002fconfiguration_003alocation_002ddesignator_002dp"></a>
<p>Is <code>x</code> a designator for a location?
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003alocation_002dfunction_002dp"></a><dl>
<dt><a name="index-location_002dfunction_002dp"></a>Function: <strong>location-function-p</strong> <em>x</em></dt>
<dd><a name="index-uiop_002fconfiguration_003alocation_002dfunction_002dp"></a>
<p>Is <code>x</code> the specification of a location function?
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003aregister_002dclear_002dconfiguration_002dhook"></a><dl>
<dt><a name="index-register_002dclear_002dconfiguration_002dhook"></a>Function: <strong>register-clear-configuration-hook</strong> <em>hook-function &amp;optional  call-now-p</em></dt>
<dd><a name="index-uiop_002fconfiguration_003aregister_002dclear_002dconfiguration_002dhook"></a>
<p>Register a function to be called when clearing configuration
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003areport_002dinvalid_002dform"></a><dl>
<dt><a name="index-report_002dinvalid_002dform"></a>Function: <strong>report-invalid-form</strong> <em>reporter &amp;rest  args</em></dt>
<dd><a name="index-uiop_002fconfiguration_003areport_002dinvalid_002dform"></a>
<p>Report an invalid form according to <code>reporter</code> and various <code>args</code>
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003aresolve_002dabsolute_002dlocation"></a><dl>
<dt><a name="index-resolve_002dabsolute_002dlocation"></a>Function: <strong>resolve-absolute-location</strong> <em>x &amp;key  ensure-directory wilden</em></dt>
<dd><a name="index-uiop_002fconfiguration_003aresolve_002dabsolute_002dlocation"></a>
<p>Given a designator <code>x</code> for an absolute location, resolve it to a pathname
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003aresolve_002dlocation"></a><dl>
<dt><a name="index-resolve_002dlocation"></a>Function: <strong>resolve-location</strong> <em>x &amp;key  ensure-directory wilden directory</em></dt>
<dd><a name="index-uiop_002fconfiguration_003aresolve_002dlocation"></a>
<p>Resolve location designator <code>x</code> into a <code>pathname</code>
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003aresolve_002drelative_002dlocation"></a><dl>
<dt><a name="index-resolve_002drelative_002dlocation"></a>Function: <strong>resolve-relative-location</strong> <em>x &amp;key  ensure-directory wilden</em></dt>
<dd><a name="index-uiop_002fconfiguration_003aresolve_002drelative_002dlocation"></a>
<p>Given a designator <code>x</code> for an relative location, resolve it to a pathname.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003asystem_002dconfig_002dpathnames"></a><dl>
<dt><a name="index-system_002dconfig_002dpathnames"></a>Function: <strong>system-config-pathnames</strong> <em>&amp;rest  more</em></dt>
<dd><a name="index-uiop_002fconfiguration_003asystem_002dconfig_002dpathnames"></a>
<p>Return a list of directories where are stored the system&rsquo;s default user configuration information.
<code>more</code> may contain specifications for a subpath relative to these directories: a
subpathname specification and keyword arguments as per <code>resolve-location</code> (see
also &quot;Configuration DSL&quot;) in the ASDF manual.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003asystem_002dconfiguration_002ddirectories"></a><dl>
<dt><a name="index-system_002dconfiguration_002ddirectories"></a>Function: <strong>system-configuration-directories</strong></dt>
<dd><a name="index-uiop_002fconfiguration_003asystem_002dconfiguration_002ddirectories"></a>
<p>Return the list of system configuration directories for common-lisp.
<code>deprecated</code>. Use <code>uiop:config-system-pathnames</code> instead.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003aupgrade_002dconfiguration"></a><dl>
<dt><a name="index-upgrade_002dconfiguration"></a>Function: <strong>upgrade-configuration</strong></dt>
<dd><a name="index-uiop_002fconfiguration_003aupgrade_002dconfiguration"></a>
<p>If a previous version of ASDF failed to read some configuration, try again now.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003auser_002dconfiguration_002ddirectories"></a><dl>
<dt><a name="index-user_002dconfiguration_002ddirectories"></a>Function: <strong>user-configuration-directories</strong></dt>
<dd><a name="index-uiop_002fconfiguration_003auser_002dconfiguration_002ddirectories"></a>
<p>Return the current user&rsquo;s list of user configuration directories
for configuring common-lisp.
<code>deprecated</code>. Use <code>uiop:xdg-config-pathnames</code> instead.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003avalidate_002dconfiguration_002ddirectory"></a><dl>
<dt><a name="index-validate_002dconfiguration_002ddirectory"></a>Function: <strong>validate-configuration-directory</strong> <em>directory tag validator &amp;key  invalid-form-reporter</em></dt>
<dd><a name="index-uiop_002fconfiguration_003avalidate_002dconfiguration_002ddirectory"></a>
<p>Map the <code>validator</code> across the .conf files in <code>directory</code>, the <code>tag</code> will
be applied to the results to yield a configuration form.  Current
values of <code>tag</code> include :source-registry and :output-translations.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003avalidate_002dconfiguration_002dfile"></a><dl>
<dt><a name="index-validate_002dconfiguration_002dfile"></a>Function: <strong>validate-configuration-file</strong> <em>file validator &amp;key  description</em></dt>
<dd><a name="index-uiop_002fconfiguration_003avalidate_002dconfiguration_002dfile"></a>
<p>Validate a configuration <code>file</code>.  The configuration file should have only one s-expression
in it, which will be checked with the <code>validator</code> <code>form</code>.  <code>description</code> argument used for error
reporting.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003avalidate_002dconfiguration_002dform"></a><dl>
<dt><a name="index-validate_002dconfiguration_002dform"></a>Function: <strong>validate-configuration-form</strong> <em>form tag directive-validator &amp;key  location invalid-form-reporter</em></dt>
<dd><a name="index-uiop_002fconfiguration_003avalidate_002dconfiguration_002dform"></a>
<p>Validate a configuration <code>form</code>. By default it will raise an error if the
<code>form</code> is not valid.  Otherwise it will return the validated form.
     Arguments control the behavior:
     The configuration <code>form</code> should be of the form (<code>tag</code> . &lt;rest&gt;)
     Each element of &lt;rest&gt; will be checked by first seeing if it&rsquo;s a configuration inheritance
directive (see <code>configuration-inheritance-directive-p</code>) then invoking <code>directive-validator</code>
on it.
     In the event of an invalid form, <code>invalid-form-reporter</code> will be used to control
reporting (see <code>report-invalid-form</code>) with <code>location</code> providing information about where
the configuration form appeared.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003axdg_002dcache_002dhome"></a><dl>
<dt><a name="index-xdg_002dcache_002dhome"></a>Function: <strong>xdg-cache-home</strong> <em>&amp;rest  more</em></dt>
<dd><a name="index-uiop_002fconfiguration_003axdg_002dcache_002dhome"></a>
<p>The base directory relative to which user specific non-essential data files should be stored.
Returns an absolute directory pathname.
<code>more</code> may contain specifications for a subpath relative to this directory: a
subpathname specification and keyword arguments as per <code>resolve-location</code> (see
also &quot;Configuration DSL&quot;) in the ASDF manual.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003axdg_002dconfig_002ddirs"></a><dl>
<dt><a name="index-xdg_002dconfig_002ddirs"></a>Function: <strong>xdg-config-dirs</strong> <em>&amp;rest  more</em></dt>
<dd><a name="index-uiop_002fconfiguration_003axdg_002dconfig_002ddirs"></a>
<p>The preference-ordered set of additional base paths to search for configuration files.
Returns a list of absolute directory pathnames.
<code>more</code> may contain specifications for a subpath relative to these directories:
subpathname specification and keyword arguments as per <code>resolve-location</code> (see
also &quot;Configuration DSL&quot;) in the ASDF manual.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003axdg_002dconfig_002dhome"></a><dl>
<dt><a name="index-xdg_002dconfig_002dhome"></a>Function: <strong>xdg-config-home</strong> <em>&amp;rest  more</em></dt>
<dd><a name="index-uiop_002fconfiguration_003axdg_002dconfig_002dhome"></a>
<p>Returns a pathname for the directory containing user-specific configuration files.
<code>more</code> may contain specifications for a subpath relative to this directory: a
subpathname specification and keyword arguments as per <code>resolve-location</code> (see
also &quot;Configuration DSL&quot;) in the ASDF manual.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003axdg_002dconfig_002dpathnames"></a><dl>
<dt><a name="index-xdg_002dconfig_002dpathnames"></a>Function: <strong>xdg-config-pathnames</strong> <em>&amp;rest  more</em></dt>
<dd><a name="index-uiop_002fconfiguration_003axdg_002dconfig_002dpathnames"></a>
<p>Return a list of pathnames for application configuration.
<code>more</code> may contain specifications for a subpath relative to these directories: a
subpathname specification and keyword arguments as per <code>resolve-location</code> (see
also &quot;Configuration DSL&quot;) in the ASDF manual.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003axdg_002ddata_002ddirs"></a><dl>
<dt><a name="index-xdg_002ddata_002ddirs"></a>Function: <strong>xdg-data-dirs</strong> <em>&amp;rest  more</em></dt>
<dd><a name="index-uiop_002fconfiguration_003axdg_002ddata_002ddirs"></a>
<p>The preference-ordered set of additional paths to search for data files.
Returns a list of absolute directory pathnames.
<code>more</code> may contain specifications for a subpath relative to these directories: a
subpathname specification and keyword arguments as per <code>resolve-location</code> (see
also &quot;Configuration DSL&quot;) in the ASDF manual.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003axdg_002ddata_002dhome"></a><dl>
<dt><a name="index-xdg_002ddata_002dhome"></a>Function: <strong>xdg-data-home</strong> <em>&amp;rest  more</em></dt>
<dd><a name="index-uiop_002fconfiguration_003axdg_002ddata_002dhome"></a>
<p>Returns an absolute pathname for the directory containing user-specific data files.
<code>more</code> may contain specifications for a subpath relative to this directory: a
subpathname specification and keyword arguments as per <code>resolve-location</code> (see
also &quot;Configuration DSL&quot;) in the ASDF manual.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003axdg_002ddata_002dpathnames"></a><dl>
<dt><a name="index-xdg_002ddata_002dpathnames"></a>Function: <strong>xdg-data-pathnames</strong> <em>&amp;rest  more</em></dt>
<dd><a name="index-uiop_002fconfiguration_003axdg_002ddata_002dpathnames"></a>
<p>Return a list of absolute pathnames for application data directories.  With <code>app</code>,
returns directory for data for that application, without <code>app</code>, returns the set of directories
for storing all application configurations.
<code>more</code> may contain specifications for a subpath relative to these directories: a
subpathname specification and keyword arguments as per <code>resolve-location</code> (see
also &quot;Configuration DSL&quot;) in the ASDF manual.
</p></dd></dl>
<a name="Function-uiop_002fconfiguration_003axdg_002druntime_002ddir"></a><dl>
<dt><a name="index-xdg_002druntime_002ddir"></a>Function: <strong>xdg-runtime-dir</strong> <em>&amp;rest  more</em></dt>
<dd><a name="index-uiop_002fconfiguration_003axdg_002druntime_002ddir"></a>
<p>Pathname for user-specific non-essential runtime files and other file objects,
such as sockets, named pipes, etc.
Returns an absolute directory pathname.
<code>more</code> may contain specifications for a subpath relative to this directory: a
subpathname specification and keyword arguments as per <code>resolve-location</code> (see
also &quot;Configuration DSL&quot;) in the ASDF manual.
</p></dd></dl>
<a name="Variable-uiop_002fconfiguration_003a_002ahere_002ddirectory_002a"></a><dl>
<dt><a name="index-_002ahere_002ddirectory_002a"></a>Variable: <strong>*here-directory*</strong></dt>
<dd><a name="index-uiop_002fconfiguration_003a_002ahere_002ddirectory_002a"></a>
<p>This special variable is bound to the currect directory during calls to
<code>process-source-registry</code> in order that we be able to interpret the :here
directive.
</p></dd></dl>
<a name="Variable-uiop_002fconfiguration_003a_002aignored_002dconfiguration_002dform_002a"></a><dl>
<dt><a name="index-_002aignored_002dconfiguration_002dform_002a"></a>Variable: <strong>*ignored-configuration-form*</strong></dt>
<dd><a name="index-uiop_002fconfiguration_003a_002aignored_002dconfiguration_002dform_002a"></a>
<p>Have configuration forms been ignored while parsing the configuration?
</p></dd></dl>
<a name="Variable-uiop_002fconfiguration_003a_002auser_002dcache_002a"></a><dl>
<dt><a name="index-_002auser_002dcache_002a"></a>Variable: <strong>*user-cache*</strong></dt>
<dd><a name="index-uiop_002fconfiguration_003a_002auser_002dcache_002a"></a>
<p>A specification as per <code>resolve-location</code> of where the user keeps his FASL cache
</p></dd></dl>

<hr>
<a name="UIOP_002fBACKWARD_002dDRIVER"></a>
<div class="header">
<p>
Next: <a href="#UIOP_002fDRIVER" accesskey="n" rel="next">UIOP/DRIVER</a>, Previous: <a href="#UIOP_002fCONFIGURATION" accesskey="p" rel="prev">UIOP/CONFIGURATION</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fBACKWARD_002dDRIVER-1"></a>
<h2 class="chapter">15 UIOP/BACKWARD-DRIVER</h2>

<p><code>uiop/backward-driver</code> provides backward-compatibility with
earlier incarnations of this library.
</p>
<a name="Function-uiop_002fbackward_002ddriver_003acoerce_002dpathname"></a><dl>
<dt><a name="index-coerce_002dpathname"></a>Function: <strong>coerce-pathname</strong> <em>name &amp;key  type defaults</em></dt>
<dd><a name="index-uiop_002fbackward_002ddriver_003acoerce_002dpathname"></a>
<p><code>deprecated</code>. Please use <code>uiop:parse-unix-namestring</code> instead.
</p></dd></dl>
<a name="Function-uiop_002fbackward_002ddriver_003ain_002dfirst_002ddirectory"></a><dl>
<dt><a name="index-in_002dfirst_002ddirectory-1"></a>Function: <strong>in-first-directory</strong> <em>dirs x &amp;key  direction</em></dt>
<dd><a name="index-uiop_002fbackward_002ddriver_003ain_002dfirst_002ddirectory"></a>
<p>Finds the first appropriate file named <code>x</code> in the list of <code>dirs</code> for I/O
in <code>direction</code> (which may be <code>:input</code>, <code>:output</code>, <code>:io</code>, or <code>:probe</code>).
If direction is <code>:input</code> or <code>:probe</code>, will return the first extant file named
<code>x</code> in one of the <code>dirs</code>.
If direction is <code>:output</code> or <code>:io</code>, will simply return the file named <code>x</code> in the
first element of <code>dirs</code> that exists. <code>deprecated</code>.
</p></dd></dl>
<a name="Function-uiop_002fbackward_002ddriver_003ain_002dsystem_002dconfiguration_002ddirectory"></a><dl>
<dt><a name="index-in_002dsystem_002dconfiguration_002ddirectory-1"></a>Function: <strong>in-system-configuration-directory</strong> <em>x &amp;key  direction</em></dt>
<dd><a name="index-uiop_002fbackward_002ddriver_003ain_002dsystem_002dconfiguration_002ddirectory"></a>
<p>Return the pathname for the file named <code>x</code> under the system configuration directory
for common-lisp. <code>deprecated</code>.
</p></dd></dl>
<a name="Function-uiop_002fbackward_002ddriver_003ain_002duser_002dconfiguration_002ddirectory"></a><dl>
<dt><a name="index-in_002duser_002dconfiguration_002ddirectory-1"></a>Function: <strong>in-user-configuration-directory</strong> <em>x &amp;key  direction</em></dt>
<dd><a name="index-uiop_002fbackward_002ddriver_003ain_002duser_002dconfiguration_002ddirectory"></a>
<p>Return the file named <code>x</code> in the user configuration directory for common-lisp.
<code>deprecated</code>.
</p></dd></dl>
<a name="Function-uiop_002fbackward_002ddriver_003asystem_002dconfiguration_002ddirectories"></a><dl>
<dt><a name="index-system_002dconfiguration_002ddirectories-1"></a>Function: <strong>system-configuration-directories</strong></dt>
<dd><a name="index-uiop_002fbackward_002ddriver_003asystem_002dconfiguration_002ddirectories"></a>
<p>Return the list of system configuration directories for common-lisp.
<code>deprecated</code>. Use <code>uiop:config-system-pathnames</code> instead.
</p></dd></dl>
<a name="Function-uiop_002fbackward_002ddriver_003auser_002dconfiguration_002ddirectories"></a><dl>
<dt><a name="index-user_002dconfiguration_002ddirectories-1"></a>Function: <strong>user-configuration-directories</strong></dt>
<dd><a name="index-uiop_002fbackward_002ddriver_003auser_002dconfiguration_002ddirectories"></a>
<p>Return the current user&rsquo;s list of user configuration directories
for configuring common-lisp.
<code>deprecated</code>. Use <code>uiop:xdg-config-pathnames</code> instead.
</p></dd></dl>
<a name="Function-uiop_002fbackward_002ddriver_003aversion_002dcompatible_002dp"></a><dl>
<dt><a name="index-version_002dcompatible_002dp"></a>Function: <strong>version-compatible-p</strong> <em>provided-version required-version</em></dt>
<dd><a name="index-uiop_002fbackward_002ddriver_003aversion_002dcompatible_002dp"></a>
<p>Is the provided version a compatible substitution for the required-version?
If major versions differ, it&rsquo;s not compatible.
If they are equal, then any later version is compatible,
with later being determined by a lexicographical comparison of minor numbers.
<code>deprecated</code>.
</p></dd></dl>

<hr>
<a name="UIOP_002fDRIVER"></a>
<div class="header">
<p>
Previous: <a href="#UIOP_002fBACKWARD_002dDRIVER" accesskey="p" rel="prev">UIOP/BACKWARD-DRIVER</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UIOP_002fDRIVER-1"></a>
<h2 class="chapter">16 UIOP/DRIVER</h2>

<p><code>uiop/driver</code> doesn&rsquo;t export any new symbols. It just exists to
reexport all the utilities in a single package <code>uiop</code>.
</p>
<hr>



</body>
</html>
